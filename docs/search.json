[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 interfacer authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/interfacer.html","id":"defining-an-interface","dir":"Articles","previous_headings":"","what":"Defining an interface","title":"interfacer","text":"interface defines structure acceptable dataframes. list column names, plus types documentation column. Printing interface specification shows structure. dataframe containing following columns: id (integer) - integer ID test (logical) - test result Grouping undefined interface specification can used default value function. dummy default value combined ivalidate function body passed parameter can validated ensure dataframe right shape. can use idocument Roxygen skeleton document dataframe constraints. case later call function data checked pass non-conformant data ivalidate throws error: can recover error including mapping applied validation using imap (essentially used dplyr::mutate call) interface specifications can extended. : used another function. case ivalidate call prunes unneeded data dataframe, also ensures correct grouping. rejected grouping incorrect Following error message makes validate fine documentation second interface follows: Missing columns can inserted imap. Types coerced expected type possible warnings. Incorrect data types picked rejected. case data supplied id cast integer without loss. Similar behaviour seen logical data anything 0 1 example. Factors might allowable levels well. define enum accepts list values, relevel factor. .drop = TRUE specified values don’t match levels cast NA rather causing failure allow conformance subset factor values.","code":".iface = iface(   id = integer ~ \"an integer ID\",   test = logical ~ \"the test result\" ) .iface #' An example function #' #' @param mydata `r idocument(example_fn, mydata)` #' @param another an example    #' @param ... not used #' #' @return the conformant dataframe #' @export example_fn = function(   mydata = .iface,   another = \"value\",   ... ) {   mydata = ivalidate(...)   return(mydata) } example_data = tibble::tibble(     id=c(1,2,3),     test = c(TRUE,FALSE,TRUE)   )  # this returns the qualifying data example_fn(   example_data,    \"value for another\" ) #> # A tibble: 3 × 2 #>      id test  #>   <int> <lgl> #> 1     1 TRUE  #> 2     2 FALSE #> 3     3 TRUE example_data_2 = tibble::tibble(     id=c(1,2,3),     wrong_test = c(TRUE,FALSE,TRUE)   )  # this causes an error as example_data_2$wrong_test is wrongly named try(example_fn(   example_data_2,    \"value for another\" )) #> Error in iconvert(df, spec, .imap, dname, .get_fn_name(fn), .has_dots,  :  #>   1 missing columns in parameter `mydata` in call to example_fn(...) #> consider renaming to create `test` columns #> or by adding `.imap = interfacer::imap(`test` = ???)` to your function call. example_fn(   example_data_2,    \"value for another\",   .imap = imap(test = wrong_test) ) #> # A tibble: 3 × 3 #>      id wrong_test test  #>   <int> <lgl>      <lgl> #> 1     1 TRUE       TRUE  #> 2     2 FALSE      FALSE #> 3     3 TRUE       TRUE .iface2 = iface(   .iface,   extra = character ~ \"a new value\",   .groups = FALSE )  print(.iface2) #> A dataframe containing the following columns:  #> * extra (character) - a new value #> * id (integer) - an integer ID #> * test (logical) - the test result #> Ungrouped example_fn2 = function(     mydata = .iface2,     ... ) {   mydata = ivalidate(mydata, ..., .prune = TRUE)   return(mydata) } example_data_3 = tibble::tibble(     id=c(1,2,3),     test = c(TRUE,FALSE,TRUE),     extra = c(\"a\",\"b\",\"c\"),     unneeded = c(\"x\",\"y\",\"z\")   ) %>% dplyr::group_by(id) try(example_fn2(example_data_3)) #> Error in iconvert(df, spec, .imap, dname, .get_fn_name(fn), .has_dots,  :  #>   the specified dataframe grouping (<none>) does not match actual grouping (id) #> consider regrouping your data before calling function `example_fn2`, e.g.: #> `df %>% ungroup() %>% example_fn2(...)` #> or calling function `example_fn2` using a group_modify, e.g.: #> `df %>% group_modify(function(d,g,...) {example_fn2(mydata=d, ...)})` example_fn2(example_data_3 %>% dplyr::ungroup()) #> # A tibble: 3 × 3 #>   extra    id test  #>   <chr> <int> <lgl> #> 1 a         1 TRUE  #> 2 b         2 FALSE #> 3 c         3 TRUE cat(idocument(example_fn2)) #> A dataframe containing the following columns:  #>  #> - extra (character) - a new value #> - id (integer) - an integer ID #> - test (logical) - the test result #>  #> Ungrouped example_fn2(   tibble::tibble(     id=c(\"1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE)   ), .imap = imap(extra=\"fixed\") ) #> # A tibble: 3 × 3 #>   extra    id test  #>   <chr> <int> <lgl> #> 1 fixed     1 TRUE  #> 2 fixed     2 FALSE #> 3 fixed     3 TRUE try(example_fn(   tibble::tibble(     id= c(\"1.1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE)   ))) #> Error in pmap(.l, .f, ..., .progress = .progress) :  #>   ℹ In index: 1. #> Caused by error in `value[[3L]]()`: #> ! input column `id` in function parameter `example_fn(mydata = ?)` cannot be coerced to a integer: not a true integer input if (rlang::is_installed(\"ggplot2\")) {      i_diamonds = iface(      color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",     cut = enum(Ideal, Premium, .drop=TRUE) ~ \"the cut\",     price = integer ~ \"the price\"   )      # itest(ggplot2::diamonds, i_diamonds)   iconvert(ggplot2::diamonds, i_diamonds, .prune = TRUE)    } #> # A tibble: 53,940 × 3 #>    color cut     price #>    <fct> <fct>   <int> #>  1 E     Ideal     326 #>  2 E     Premium   326 #>  3 E     NA        327 #>  4 I     Premium   334 #>  5 J     NA        335 #>  6 J     NA        336 #>  7 I     NA        336 #>  8 H     NA        337 #>  9 E     NA        337 #> 10 H     NA        338 #> # ℹ 53,930 more rows"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rob Challen. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2023). interfacer: Define Enforce Interface Contracts Dataframes. R package version 0.0.6.","code":"@Manual{,   title = {interfacer: Define and Enforce Interface Contracts for Dataframes},   author = {Rob Challen},   year = {2023},   note = {R package version 0.0.6}, }"},{"path":"/index.html","id":"interfacer","dir":"","previous_headings":"","what":"Define and Enforce Interface Contracts for Dataframes","title":"Define and Enforce Interface Contracts for Dataframes","text":"Interfacer provides framework specifying structure dataframes parameters user functions checking user supplied dataframes conform expectations. Missing columns incorrectly typed columns can identified useful error messages returned. Specifying structure part function definition can automatically included Roxygen documentation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Define and Enforce Interface Contracts for Dataframes","text":"package hosted Bristol Vaccine Centre r-universe. Installation follows: can install development version interfacer GitHub : likely though including another package via DESCRIPTION file:","code":"options(repos = c(   \"bristol-vaccine-centre\" = 'https://https://bristol-vaccine-centre.r-universe.dev/',   CRAN = 'https://cloud.r-project.org'))  # Download and install interfacer in R install.packages(\"interfacer\") # install.packages(\"devtools\") devtools::install_github(\"bristol-vaccine-centre/interfacer\") ... Imports:      tidyverse,     interfacer Remotes: interfacer=github::bristol-vaccine-centre/interfacer Suggests:      knitr,     rmarkdown ..."},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Define and Enforce Interface Contracts for Dataframes","text":"interfacer used within function definition new package ","code":"#' An example function #' #' @param mydata `r interfacer::idocument(example_fn, mydata)` #' @param another an example    #' @param ... not used #' #' @return ... something not yet defined ... #' @export example_fn = function(      # this parameter will be a dataframe with id and test columns   mydata = interfacer::iface(     id = integer ~ \"an integer ID\",     test = logical ~ \"the test result\"   ),      another = \"value\",   ... ) {   mydata = interfacer::ivalidate(mydata, ...)   # rest of function body ... }"},{"path":"/reference/as_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"Reuse tidy-select syntax outside tidy-select function","code":""},{"path":"/reference/as_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"","code":"as_vars(tidyselect, data = NULL)"},{"path":"/reference/as_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"tidyselect tidyselect syntax evaluated context looking call call stack includes dataframe first argument data (optional) specific dataframe evaluate tidyselect","code":""},{"path":"/reference/as_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"list symbols resulting evaluation tidyselect context current call stack (provided data frame)","code":""},{"path":"/reference/enum.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a factor with specific levels. — enum","title":"Define a factor with specific levels. — enum","text":"Define factor specific levels.","code":""},{"path":"/reference/enum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a factor with specific levels. — enum","text":"","code":"enum(..., .drop = FALSE)"},{"path":"/reference/enum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a factor with specific levels. — enum","text":"... levels (quotes, backticks required) .drop levels present data specified cause error (FALSE default) silently dropped NA values (TRUE).","code":""},{"path":"/reference/enum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a factor with specific levels. — enum","text":"function can check convert input factor specified levels. re-level factors matching levels different order.","code":""},{"path":"/reference/enum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a factor with specific levels. — enum","text":"","code":"f = enum(one,two,three) f(c(\"three\",\"two\",\"one\")) #> [1] three two   one   #> Levels: one two three f(factor(rep(1:3,5), labels = c(\"one\",\"two\",\"three\"))) #>  [1] one   two   three one   two   three one   two   three one   two   three #> [13] one   two   three #> Levels: one two three"},{"path":"/reference/format.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Encode in a Common Format — format.iface","title":"Encode in a Common Format — format.iface","text":"Format R object pretty printing.","code":""},{"path":"/reference/format.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Encode in a Common Format — format.iface","text":"","code":"# S3 method for iface format(x, ...)"},{"path":"/reference/format.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Encode in a Common Format — format.iface","text":"x R object (conceptually); typically numeric. ... arguments passed methods.","code":""},{"path":"/reference/format.iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Encode in a Common Format — format.iface","text":"object similar structure x containing character   representations elements first argument x common format, current locale's encoding. character, numeric, complex factor x, dims dimnames   preserved matrices/arrays names vectors:   attributes copied. x list, result character vector obtained   applying format.default(x, ...) element list   (unlisting elements lists),   collapsing result element  paste(collapse = \", \").  defaults case  trim = TRUE, justify = \"none\" since one usually want   alignment collapsed strings.","code":""},{"path":"/reference/format.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Encode in a Common Format — format.iface","text":"format generic function.  Apart methods described   methods dates (see format.Date),   date-times (see format.POSIXct) classes   format.octmode format.dist. format.data.frame formats data frame column column,   applying appropriate method format column.   Methods columns often similar .character offer   control.  Matrix data-frame columns converted   separate columns result, character columns (normally )   given class \"AsIs\". format.factor converts factor character vector   calls default method (justify applies). format.AsIs deals columns complicated objects   extracted data frame.  Character objects (atomic)   matrices passed default method (width   apply).   Otherwise calls toString convert object   character (vector list, element element)   right-justifies result. Justification character vectors (objects converted   character vectors methods) done display width (see   nchar), taking double-width characters rendering   special characters (escape sequences, including escaping   backslash double quote: see print.default)   account.  Thus width displayed print(quote =   FALSE) displayed cat.  Character strings   padded blanks display width widest.  (  na.encode = FALSE missing character strings included   width computations encoded.) Numeric vectors encoded minimum number decimal places   needed display elements least digits   significant digits.  However, elements trailing   zeroes, number decimal places reduced least one   element non-zero final digit; see also argument   documentation big.*, small.* etc, .  See   note print.default digits >= 16. Raw vectors converted 2-digit hexadecimal representation   .character. format.default(x) now provides “minimal” string   isS4(x) true. internal code respects option   getOption(\"OutDec\") ‘decimal mark’,   set something \".\" takes precedence   argument decimal.mark.","code":""},{"path":"/reference/format.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Encode in a Common Format — format.iface","text":"Becker, R. ., Chambers, J. M. Wilks, . R. (1988)   New S Language.   Wadsworth & Brooks/Cole.","code":""},{"path":[]},{"path":"/reference/format.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Encode in a Common Format — format.iface","text":"","code":"format(1:10) #>  [1] \" 1\" \" 2\" \" 3\" \" 4\" \" 5\" \" 6\" \" 7\" \" 8\" \" 9\" \"10\" format(1:10, trim = TRUE) #>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"  zz <- data.frame(\"(row names)\"= c(\"aaaaa\", \"b\"), check.names = FALSE) format(zz) #>   (row names) #> 1       aaaaa #> 2           b format(zz, justify = \"left\") #>   (row names) #> 1       aaaaa #> 2       b      ## use of nsmall format(13.7) #> [1] \"13.7\" format(13.7, nsmall = 3) #> [1] \"13.700\" format(c(6.0, 13.1), digits = 2) #> [1] \" 6\" \"13\" format(c(6.0, 13.1), digits = 2, nsmall = 1) #> [1] \" 6.0\" \"13.1\"  ## use of scientific format(2^31-1) #> [1] \"2147483647\" format(2^31-1, scientific = TRUE) #> [1] \"2.147484e+09\"  ## a list z <- list(a = letters[1:3], b = (-pi+0i)^((-2:2)/2), c = c(1,10,100,1000),           d = c(\"a\", \"longer\", \"character\", \"string\"),           q = quote( a + b ), e = expression(1+x)) ## can you find the \"2\" small differences? (f1 <- format(z, digits = 2)) #>                                                              a  #>                                                      \"a, b, c\"  #>                                                              b  #> \"-0.32+0.00i, 0.00-0.56i, 1.00+0.00i, 0.00+1.77i, -3.14+0.00i\"  #>                                                              c  #>                                             \"1, 10, 100, 1000\"  #>                                                              d  #>                   \"a        , longer   , character, string   \"  #>                                                              q  #>                                                        \"a + b\"  #>                                                              e  #>                                            \"expression(1 + x)\"  (f2 <- format(z, digits = 2, justify = \"left\", trim = FALSE)) #>                                                                 a  #>                                                         \"a, b, c\"  #>                                                                 b  #> \"-0.32+0.00i,  0.00-0.56i,  1.00+0.00i,  0.00+1.77i, -3.14+0.00i\"  #>                                                                 c  #>                                          \"   1,   10,  100, 1000\"  #>                                                                 d  #>                      \"a        , longer   , character, string   \"  #>                                                                 q  #>                                                           \"a + b\"  #>                                                                 e  #>                                               \"expression(1 + x)\"  f1 == f2 ## 2 FALSE, 4 TRUE #>     a     b     c     d     q     e  #>  TRUE FALSE FALSE  TRUE  TRUE  TRUE   ## A \"minimal\" format() for S4 objects without their own format() method: cc <- methods::getClassDef(\"standardGeneric\") format(cc) ## \"<S4 class ......>\" #> [1] \"<S4 class ‘classRepresentation’ [package “methods”] with 11 slots>\""},{"path":"/reference/iclip.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an iface interface from an example dataframe — iclip","title":"Create an iface interface from an example dataframe — iclip","text":"Copies clipboard","code":""},{"path":"/reference/iclip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an iface interface from an example dataframe — iclip","text":"","code":"iclip(df)"},{"path":"/reference/iclip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an iface interface from an example dataframe — iclip","text":"df prototype dataframe","code":""},{"path":"/reference/iclip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an iface interface from an example dataframe — iclip","text":"nothing","code":""},{"path":"/reference/iclip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an iface interface from an example dataframe — iclip","text":"","code":"if(FALSE) iclip(iris)"},{"path":"/reference/iconvert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dataframe to a format compatible with an interface specification — iconvert","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"function called ivalidate generally intended used directly end user. may helpful debugging package development know used.","code":""},{"path":"/reference/iconvert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"","code":"iconvert(   df,   iface,   .imap = interfacer::imap(),   .dname = \"<unknown>\",   .fname = \"<unknown>\",   .has_dots = TRUE,   .prune = FALSE )"},{"path":"/reference/iconvert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"df dataframe convert iface interface spec iface .imap optional imap mapping .dname name parameter value (optional). .fname name function (optional). .has_dots internal library use . Changes nature error message. .prune want remove","code":""},{"path":"/reference/iconvert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"conformant dataframe","code":""},{"path":"/reference/iconvert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"","code":"i_diamonds = iface(    color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",    price = integer ~ \"the price\" ) iconvert(ggplot2::diamonds, i_diamonds,.prune = TRUE) #> # A tibble: 53,940 × 2 #>    color price #>    <fct> <int> #>  1 E       326 #>  2 E       326 #>  3 E       327 #>  4 I       334 #>  5 J       335 #>  6 J       336 #>  7 I       336 #>  8 H       337 #>  9 E       337 #> 10 H       338 #> # ℹ 53,930 more rows"},{"path":"/reference/idocument.html","id":null,"dir":"Reference","previous_headings":"","what":"Document an interface contract for inserting in to Roxygen — idocument","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"function expected called within documentation function inline code parameter documentation function. details expected columns input dataframe possess.","code":""},{"path":"/reference/idocument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"","code":"idocument(fn, param = NULL)"},{"path":"/reference/idocument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"fn function documenting param parameter documenting (optional. missing defaults first argument function)","code":""},{"path":"/reference/idocument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"markdown snippet","code":""},{"path":"/reference/idocument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"","code":"#' @param df `r idocument(x, df)` x = function(df = iface( col1 = integer ~ \"an integer column\" )) {}  cat(idocument(x, df)) #> A dataframe containing the following columns:  #>  #> - col1 (integer) - an integer column #>  #> Grouping undefined"},{"path":"/reference/iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Define an interface — iface","title":"Define an interface — iface","text":"defines structure dataframe. specification form named list formulae structure name = type ~ \"documentation\". type can one 'integer','double','numeric','date','logical','factor','character','primary_key' enum(level1,level2,...) anything resolves function e.g. .ordered","code":""},{"path":"/reference/iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an interface — iface","text":"","code":"iface(..., .groups = NULL)"},{"path":"/reference/iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an interface — iface","text":"... specification interface (see details), unnamed iface object extend, . .groups either FALSE groups formula form ~ var1 + var2 + ... defines columns must grouped dataframe (order). NULL (default) grouping validated.","code":""},{"path":"/reference/iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define an interface — iface","text":"definition interface iface object","code":""},{"path":"/reference/iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define an interface — iface","text":"","code":"my_iface = iface( col1 = integer ~ \"an integer column\" ) print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer) - an integer column #> Grouping undefined  x = function(df = my_iface, ...) {   df = ivalidate(df,...)   return(df) }  x(tibble::tibble(col1 = c(1,2,3))) #> Error in eval(icall): object 'my_iface' not found  my_iface2 = iface(my_iface, col2 = character ~ \"another col\", .groups = ~ col1 + col2) print(my_iface2) #> A dataframe containing the following columns:  #> * col1 (integer) - an integer column #> * col2 (character) - another col #> Grouped by: col1 + col2"},{"path":"/reference/imap.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify mappings that can make dataframes compatible with an interface — imap","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"function expected used .imap = imap(...) context overcome mapping issues","code":""},{"path":"/reference/imap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"imap(...)"},{"path":"/reference/imap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"... set dplyr::mutate() specifications applied dataframe rename otherwise fix missing columns","code":""},{"path":"/reference/imap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"set mappings","code":""},{"path":"/reference/imap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...) } input=tibble::tibble(col2 = c(1,2,3))  # This fails because col1 is missing try(x(input)) #> Error in iconvert(df, spec, .imap, dname, .get_fn_name(fn), .has_dots,  :  #>   1 missing columns in parameter `df` in call to x(...) #> consider renaming to create `col1` columns #> or by adding `.imap = interfacer::imap(`col1` = ???)` to your function call. #>  # This fixes it for this input x(input, .imap=imap(col1 = col2))"},{"path":"/reference/ireturn.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform interface checks on dataframe by looking at enclosing function — ireturn","title":"Perform interface checks on dataframe by looking at enclosing function — ireturn","text":"intended used within function check validity data frame parameter (usually first parameter) ispec.","code":""},{"path":"/reference/ireturn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform interface checks on dataframe by looking at enclosing function — ireturn","text":"","code":"ireturn(df, iface, .prune = FALSE)"},{"path":"/reference/ireturn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform interface checks on dataframe by looking at enclosing function — ireturn","text":"df dataframe - missing first parameter calling function assumed dataframe. iface interface specification df conform . .prune get rid excess columns spec.","code":""},{"path":"/reference/ireturn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform interface checks on dataframe by looking at enclosing function — ireturn","text":"dataframe based df validity checks passed .imap mappings applied present","code":""},{"path":"/reference/ireturn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform interface checks on dataframe by looking at enclosing function — ireturn","text":"","code":"input = iface(col_in = integer ~ \"an integer column\" ) output = iface(col_out = integer ~ \"an integer column\" ) x = function(df = input, ...) {   df = ivalidate(...)   tmp = df %>% dplyr::rename(col_out = col_in)   ireturn(tmp, output) } x(tibble::tibble(col_in = c(1,2,3))) #> Error in eval(icall): object 'input' not found output #> A dataframe containing the following columns:  #> * col_out (integer) - an integer column #> Grouping undefined"},{"path":"/reference/itest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test dataframe conformance to an interface specification. — itest","title":"Test dataframe conformance to an interface specification. — itest","text":"ivalidate throws errors deliberately however sometimes dealing invalid input may desirable. itest generally designed used within function specifies expected input using iface, allows function test given input conformant interface.","code":""},{"path":"/reference/itest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test dataframe conformance to an interface specification. — itest","text":"","code":"itest(df = NULL, iface = NULL, .imap = imap())"},{"path":"/reference/itest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test dataframe conformance to an interface specification. — itest","text":"df dataframe test. missing first parameter calling function assumed dataframe test. iface interface specification produced iface(). missing inferred current function signature. .imap optional mapping specification produced imap()","code":""},{"path":"/reference/itest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test dataframe conformance to an interface specification. — itest","text":"TRUE dataframe conformant, FALSE otherwise","code":""},{"path":"/reference/itest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test dataframe conformance to an interface specification. — itest","text":"","code":"if (rlang::is_installed(\"ggplot2\")) {   i_diamonds = iface(      color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",      price = integer ~ \"the price\"   )      # Ad hoc testing   itest(ggplot2::diamonds, i_diamonds)      # Use within function:   x = function(df = i_diamonds) {     if(itest()) message(\"PASS!\")   }      x(ggplot2::diamonds) } #> Error in eval(icall): object 'i_diamonds' not found"},{"path":"/reference/ivalidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"intended used within function check validity data frame parameter (usually first parameter) ispec.","code":""},{"path":"/reference/ivalidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"","code":"ivalidate(df = NULL, ..., .imap = imap(), .prune = FALSE)"},{"path":"/reference/ivalidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"df dataframe - missing first parameter calling function assumed dataframe. ... used ivalidate included call inherit .imap caller function. .imap set mappings imap object. .prune get rid excess columns spec.","code":""},{"path":"/reference/ivalidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"dataframe based df validity checks passed .imap mappings applied present","code":""},{"path":"/reference/ivalidate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(...)   return(df) } input=tibble::tibble(col1 = c(1,2,3)) x(input) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3  # This fails because col1 is not coercable to integer input2=tibble::tibble(col1 = c(1.5,2,3)) try(x(input2)) #> Error in pmap(.l, .f, ..., .progress = .progress) :  #>   ℹ In index: 1. #> Caused by error in `value[[3L]]()`: #> ! input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer: not a true integer input"},{"path":"/reference/knit_print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"A custom printing function — knit_print.iface","title":"A custom printing function — knit_print.iface","text":"S3 generic function knit_print default printing function knitr. chunk option render uses function default. main purpose S3 generic function customize printing R objects code chunks. can fall back normal printing behavior setting chunk option render = normal_print.","code":""},{"path":"/reference/knit_print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A custom printing function — knit_print.iface","text":"","code":"# S3 method for iface knit_print(x, ...)"},{"path":"/reference/knit_print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A custom printing function — knit_print.iface","text":"x R object printed ... Additional arguments passed S3 method. Currently ignored, except two optional arguments options inline; see references .","code":""},{"path":"/reference/knit_print.iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A custom printing function — knit_print.iface","text":"value returned print method character vector   can converted character value. can wrap value  asis_output() knitr writes character value   output.","code":""},{"path":"/reference/knit_print.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A custom printing function — knit_print.iface","text":"Users can write custom methods based generic function. example, want print data frames tables output, can define method knit_print.data.frame turns data.frame table (implementation may use R packages functions, e.g. xtable kable()).","code":""},{"path":"/reference/knit_print.iface.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"A custom printing function — knit_print.iface","text":"recommended leave ... argument method,   allow future changes knit_print() API without breaking   method.","code":""},{"path":"/reference/knit_print.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A custom printing function — knit_print.iface","text":"See vignette('knit_print', package = 'knitr').","code":""},{"path":"/reference/knit_print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A custom printing function — knit_print.iface","text":"","code":"library(knitr) # write tables for data frames knit_print.data.frame = function(x, ...) {     res = paste(c(\"\", \"\", kable(x, output = FALSE)), collapse = \"\\n\")     asis_output(res) } # register the method registerS3method(\"knit_print\", \"data.frame\", knit_print.data.frame) # after you define and register the above method, data frames will be printed # as tables in knitr, which is different with the default print() behavior"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Values — print.iface","title":"Print Values — print.iface","text":"print prints argument returns invisibly (via   invisible(x)).  generic function means   new printing methods can easily added new classes.","code":""},{"path":"/reference/print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Values — print.iface","text":"","code":"# S3 method for iface print(x, ...)"},{"path":"/reference/print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Values — print.iface","text":"x object used select method. ... arguments passed methods.","code":""},{"path":"/reference/print.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print Values — print.iface","text":"default method, print.default help page.   Use methods(\"print\") get methods   print generic. print.factor allows customization used printing   ordered factors well. print.table printing tables allows   customization.  R 3.0.0, prints description case table   0-extents (can happen classifier valid data). See noquote example class whose main   purpose specific print method.","code":""},{"path":"/reference/print.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Print Values — print.iface","text":"Chambers, J. M. Hastie, T. J. (1992)   Statistical Models S.   Wadsworth & Brooks/Cole.","code":""},{"path":[]},{"path":"/reference/print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Values — print.iface","text":"","code":"require(stats)  ts(1:20)  #-- print is the \"Default function\" --> print.ts(.) is called #> Time Series: #> Start = 1  #> End = 20  #> Frequency = 1  #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 for(i in 1:3) print(1:i) #> [1] 1 #> [1] 1 2 #> [1] 1 2 3  ## Printing of factors attenu$station ## 117 levels -> 'max.levels' depending on width #>   [1] 117  1083 1095 283  135  475  113  1008 1028 2001 117  1117 1438 1083 1013 #>  [16] 1014 1015 1016 1095 1011 1028 270  280  116  266  117  113  112  130  475  #>  [31] 269  135  1093 1093 111  116  290  112  113  128  126  127  141  266  110  #>  [46] 1027 111  125  135  475  262  269  1052 411  290  130  272  1096 1102 112  #>  [61] 113  1028 2714 2708 2715 3501 655  272  1032 1377 1028 1250 1051 1293 1291 #>  [76] 1292 283  885  <NA> 2734 <NA> 2728 1413 1445 1408 1411 1410 1409 1377 1492 #>  [91] 1251 1422 1376 <NA> 286  <NA> 5028 942  <NA> 5054 958  952  5165 117  955  #> [106] 5055 <NA> <NA> 5060 412  5053 5058 5057 <NA> 5051 <NA> 5115 <NA> 931  5056 #> [121] 5059 5061 <NA> 5062 5052 <NA> 724  <NA> 5066 5050 2316 5055 942  5028 5165 #> [136] 952  958  955  117  412  5053 5054 5058 5057 5115 5056 5060 1030 1418 1383 #> [151] 1308 1298 1299 1219 <NA> <NA> 1030 1418 1383 <NA> 1299 1308 1219 1456 5045 #> [166] 5044 5160 5043 5047 c168 5068 c118 5042 5067 5049 c204 5070 c266 c203 5069 #> [181] 5073 5072 #> 117 Levels: 1008 1011 1013 1014 1015 1016 1027 1028 1030 1032 1051 1052 ... c266  ## ordered factors: levels  \"l1 < l2 < ..\" esoph$agegp[1:12] #>  [1] 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 #> Levels: 25-34 < 35-44 < 45-54 < 55-64 < 65-74 < 75+ esoph$alcgp[1:12] #>  [1] 0-39g/day 0-39g/day 0-39g/day 0-39g/day 40-79     40-79     40-79     #>  [8] 40-79     80-119    80-119    80-119    120+      #> Levels: 0-39g/day < 40-79 < 80-119 < 120+  ## Printing of sparse (contingency) tables set.seed(521) t1 <- round(abs(rt(200, df = 1.8))) t2 <- round(abs(rt(200, df = 1.4))) table(t1, t2) # simple #>     t2 #> t1    0  1  2  3  4  5  6  7  8 10 17 21 30 #>   0  21 22 14  4  1  0  1  1  1  0  1  0  0 #>   1  25 21  7  3  4  2  1  1  1  1  0  0  0 #>   2   8 16  9  2  0  0  0  0  0  0  0  1  1 #>   3   3  7  0  2  0  0  0  0  0  0  0  0  0 #>   4   1  5  2  0  0  0  1  0  0  0  0  0  0 #>   5   1  1  1  0  0  0  0  0  0  0  0  0  0 #>   6   1  3  0  0  0  0  0  0  0  0  0  0  0 #>   7   1  0  0  0  0  0  0  0  0  0  0  0  0 #>   9   0  0  0  1  0  0  0  0  0  0  0  0  0 #>   12  1  0  0  0  0  0  0  0  0  0  0  0  0 print(table(t1, t2), zero.print = \".\") # nicer to read #>     t2 #> t1    0  1  2  3  4  5  6  7  8 10 17 21 30 #>   0  21 22 14  4  1  .  1  1  1  .  1  .  . #>   1  25 21  7  3  4  2  1  1  1  1  .  .  . #>   2   8 16  9  2  .  .  .  .  .  .  .  1  1 #>   3   3  7  .  2  .  .  .  .  .  .  .  .  . #>   4   1  5  2  .  .  .  1  .  .  .  .  .  . #>   5   1  1  1  .  .  .  .  .  .  .  .  .  . #>   6   1  3  .  .  .  .  .  .  .  .  .  .  . #>   7   1  .  .  .  .  .  .  .  .  .  .  .  . #>   9   .  .  .  1  .  .  .  .  .  .  .  .  . #>   12  1  .  .  .  .  .  .  .  .  .  .  .  .  ## same for non-integer \"table\": T <- table(t2,t1) T <- T * (1+round(rlnorm(length(T)))/4) print(T, zero.print = \".\") # quite nicer, #>     t1 #> t2       0     1     2     3     4     5     6     7     9    12 #>   0  26.25 25.00 10.00  3.75  1.50  1.25  1.25  1.00     .  2.00 #>   1  22.00 26.25 16.00 10.50 27.50  1.25  3.00     .     .     . #>   2  21.00  7.00 13.50     .  3.00  1.25     .     .     .     . #>   3   5.00  3.75  2.50  2.50     .     .     .     .  1.50     . #>   4   1.25  5.00     .     .     .     .     .     .     .     . #>   5      .  2.00     .     .     .     .     .     .     .     . #>   6   1.25  1.50     .     .  1.25     .     .     .     .     . #>   7   1.25  1.25     .     .     .     .     .     .     .     . #>   8   1.50  1.00     .     .     .     .     .     .     .     . #>   10     .  1.00     .     .     .     .     .     .     .     . #>   17  1.00     .     .     .     .     .     .     .     .     . #>   21     .     .  2.75     .     .     .     .     .     .     . #>   30     .     .  5.00     .     .     .     .     .     .     . print.table(T[,2:8] * 1e9, digits=3, zero.print = \".\") #>     t1 #> t2          1        2        3        4        5        6        7 #>   0  2.50e+10 1.00e+10 3.75e+09 1.50e+09 1.25e+09 1.25e+09 1.00e+09 #>   1  2.62e+10 1.60e+10 1.05e+10 2.75e+10 1.25e+09 3.00e+09        . #>   2  7.00e+09 1.35e+10        . 3.00e+09 1.25e+09        .        . #>   3  3.75e+09 2.50e+09 2.50e+09        .        .        .        . #>   4  5.00e+09        .        .        .        .        .        . #>   5  2.00e+09        .        .        .        .        .        . #>   6  1.50e+09        .        . 1.25e+09        .        .        . #>   7  1.25e+09        .        .        .        .        .        . #>   8  1.00e+09        .        .        .        .        .        . #>   10 1.00e+09        .        .        .        .        .        . #>   17        .        .        .        .        .        .        . #>   21        . 2.75e+09        .        .        .        .        . #>   30        . 5.00e+09        .        .        .        .        . ## still slightly inferior to  Matrix::Matrix(T)  for larger T  ## Corner cases with empty extents: table(1, NA) # < table of extent 1 x 0 > #> < table of extent 1 x 0 >"}]
