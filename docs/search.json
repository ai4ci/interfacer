[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 interfacer authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/devtools.html","id":"automating-iface-specifications","dir":"Articles","previous_headings":"","what":"Automating iface specifications","title":"Tools to work with `interfacer`","text":"Adopting interfacer package functions can go hand hand developing test data project. scenario function relies specific dataframe format, can defined using test data prototype help generate iface specification. role iclip use_iface. Suppose wish develop function supports datasets format mtcars can use mtcars dataset prototype calling iclip(mtcars). writes iface specification clipboard. Pasting gives us: instead called use_iface(mtcars) definition written file R/interfaces.R (definition updated already present). iface specifications can anywhere package hierarchy make sense keep one file. Interface specifications need exported package function (although can ). cases developer want update default column description, use_iface function used, care must taken ensure changes make written use_iface called . question removing relevant comment R/interfaces.R","code":"i_mtcars = interfacer::iface(     mpg = numeric ~ \"the mpg column\",     cyl = numeric ~ \"the cyl column\",     disp = numeric ~ \"the disp column\",     hp = numeric ~ \"the hp column\",     drat = numeric ~ \"the drat column\",     wt = numeric ~ \"the wt column\",     qsec = numeric ~ \"the qsec column\",     vs = numeric ~ \"the vs column\",     am = numeric ~ \"the am column\",     gear = numeric ~ \"the gear column\",     carb = numeric ~ \"the carb column\",     .groups = NULL )"},{"path":"/articles/devtools.html","id":"dataframe-documentation","dir":"Articles","previous_headings":"","what":"Dataframe documentation","title":"Tools to work with `interfacer`","text":"using usethis::use_data embed data package inevitably reminder document data. embedding dataframe interfacer can inspect dataframe generate template data documentation R/data.R embedding data. triggered call , example, interfacer::use_dataframe(mtcars) create entry R/data.R dataframe documentation. function uses interfacer framework generate documentation need afterwards.","code":""},{"path":"/articles/devtools.html","id":"roxygen-documentation","dir":"Articles","previous_headings":"","what":"Roxygen documentation","title":"Tools to work with `interfacer`","text":"@iparam <name> <description> tags can used roxygen documentation interfacer enabled function. enables devtools::document() automatically write documentation dataframe parameters. may require call library(interfacer) running devtools::document(). example, @iparam tag expanded include documentation expected input defined iface specification df parameter: @iparam tag picks iface specification current function parameter. flexible alternative provided idocument() allows specify function parameter wish document. useful documenting generic function may dispatch multiple functions based dataframe structures. , previous example, iface definitions defined package local variables also possible refer directly variables documentation expanded definition. also recommended way document return values:","code":"#' A function #'  #' @iparam df An input dataframe #' @return ... something ... test_function = function(df = interfacer::iface(col1 = integer ~ \"An integer value\")) {   df = interfacer::ivalidate(df)   # ... main function body ... } # This may be defined in the file R/interfaces.R i_type1 = interfacer::iface(col1 = integer ~ \"An integer value\") i_type2 = interfacer::iface(col1 = date ~ \"A date value\")  #' A mulitple dispatch function #'  #' @param df An input dataframe conforming to one of: #' `r interfacer::idocument(test_function.type1, df)` #' or #' `r interfacer::idocument(test_function.type2, df)`  #' #' @return ... something ... test_function = function(df) {   interfacer::idispatch(df,     test_function.type1 = i_type1,     test_function.type2 = i_type2   ) }  test_function.type1 = function(df = i_type1) {   # ... deal with integer input ... }  test_function.type1 = function(df = i_type2) {   # ... deal with date input ... } # This may be defined in the file R/interfaces.R i_input_type = interfacer::iface(col1 = integer ~ \"An integer value\") i_return_type = interfacer::iface(output = date ~ \"A date value\")  #' An example function #'  #' @param df An input dataframe conforming to: #' `r i_input_type`  #' #' @return a dataframe of the following format:  #' `r i_return_type` test_function = function(df = i_input_type) {   df = interfacer::ivalidate(df)   # ... main function body ...   interfacer::ireturn( ...output... , i_return_type) }"},{"path":"/articles/dispatch.html","id":"rationale","dir":"Articles","previous_headings":"","what":"Rationale","title":"Multiple dispatch based on dataframes","text":"S3 type system allows dispatch based first argument function. situation developing functions use dataframes input selecting dispatch function needs based structure input rather class. interfacer can use iface specifications associate","code":""},{"path":"/articles/dispatch.html","id":"dispatch","dir":"Articles","previous_headings":"","what":"Dispatch","title":"Multiple dispatch based on dataframes","text":"Dispatching one number functions based nature dataframe input enabled idispatch(...). emulates behaviour S3 classes dataframes, based columns also grouping. Consider following iface specifications: can create specific handlers type data decide function dispatch runtime based input dataframe. call disp_example() data matches i_test_extn specification get one type behaviour: call disp_example() data matches i_test specification get different behaviour: ’ve used mechanism, example, configure plots produced depending input.","code":"i_test = iface(   id = integer ~ \"an integer ID\",   test = logical ~ \"the test result\" )  # Extends the i_test to include an additional column i_test_extn = iface(   i_test,   extra = character ~ \"a new value\",   .groups = FALSE ) # The generic function disp_example = function(x, ...) {   idispatch(x,     disp_example.extn = i_test_extn,     disp_example.no_extn = i_test   ) }  # The handler for extended input dataframe types disp_example.extn = function(x = i_test_extn, ...) {   message(\"extended data function\")   return(colnames(x)) }  # The handler for non-extended input dataframe types disp_example.no_extn = function(x = i_test, ...) {   message(\"not extended data function\")   return(colnames(x)) } tmp = tibble::tibble(     id=c(\"1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE),     extra = 1.1 )  tmp %>% disp_example() #> extended data function #> [1] \"id\"    \"test\"  \"extra\" # this matches the i_test_extn specification: tmp2 = tibble::tibble(     id=c(\"1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE) )  tmp2 %>% disp_example() #> not extended data function #> [1] \"id\"   \"test\""},{"path":"/articles/dispatch.html","id":"recursive-dispatch","dir":"Articles","previous_headings":"Dispatch","what":"Recursive dispatch","title":"Multiple dispatch based on dataframes","text":"order rules important. general detailed specifications needing provided first, generic specifications last. can leverage create recursive functional pattern dataframe processing allows multiple inputs converge single output, also demonstrates use itest() simply checks input conforms iface specification: Processing input type 1 results one path data pipeline: Processing input type 2, results different path data pipeline, outcome: Care must taken though pattern, particularly re-using column names,datatype coercion result column types switched backwards forwards, infinite loop problems.","code":"# generic type 1 input i_input_1 = iface(   x = integer ~ \"the positives\",   n = default(100) + integer ~ \"the total\" )  # generic type 2 input i_input_2 = iface(   p = proportion ~ \"the proportion\",   n = default(100) + integer ~ \"the total\" )  # more detailed combined type 1 and 2 input i_interim = iface(   i_input_1,   i_input_2 )  # most detailed input format i_final = iface(   i_interim,   lower = double ~ \"wilson lower CI\",   upper = double ~ \"wilson lower CI\",   mean = double ~ \"wilson mean\" )  # final target output format i_target = iface(   i_final,   label = character ~ \"a printable label\" )  # processes input of type 1 and  process.input_1 = function(x = i_input_1,...) {   message(\"process input 1\")   ireturn(x %>% dplyr::mutate(p = x/n), iface = i_interim) }  process.input_2 = function(x = i_input_2,...) {   message(\"process input 2\")   ireturn(x %>% dplyr::mutate(x = floor(p*n)), iface = i_interim) }  process.interim = function(x) {   message(\"process interim\")   ireturn(x %>% dplyr::mutate(binom::binom.wilson(x,n)), iface = i_final) }  process.final = function(x) {   message(\"process final\")   ireturn(x %>% dplyr::mutate(label = sprintf(\"%1.1f%% [%1.1f%% - %1.1f%%] (%d/%d)\",      mean*100, lower*100, upper*100, x, n)), iface = i_target) }  process = function(x,...) {   # this test must be at the front to prevent infinite recursion   if (itest(x, i_target)) return(x)   out = idispatch(x,     process.final = i_final,     process.interim = i_interim,     process.input_2 = i_input_2,     process.input_1 = i_input_1   )   return(process(out)) } # tibble::tibble(x=c(10,30), n=c(NA,50)) %>% itest(i_input_1) process(tibble::tibble(x=c(10,30), n=c(NA,50))) %>% dplyr::glimpse() #> process input 1 #> process interim #> process final #> Rows: 2 #> Columns: 8 #> $ x      <int> 10, 30 #> $ n      <int> 100, 50 #> $ p      <dbl> 0.1, 0.6 #> $ method <chr> \"wilson\", \"wilson\" #> $ mean   <dbl> 0.1, 0.6 #> $ lower  <dbl> 0.05522914, 0.46181438 #> $ upper  <dbl> 0.1743657, 0.7239161 #> $ label  <chr> \"10.0% [5.5% - 17.4%] (10/100)\", \"60.0% [46.2% - 72.4%] (30/50)\" # tibble::tibble(p=0.15,n=1000) %>% itest(i_input_2) process(tibble::tibble(p=0.15,n=1000)) %>% dplyr::glimpse() #> process input 2 #> process interim #> process final #> Rows: 1 #> Columns: 8 #> $ p      <dbl> 0.15 #> $ n      <int> 1000 #> $ x      <int> 150 #> $ method <chr> \"wilson\" #> $ mean   <dbl> 0.15 #> $ lower  <dbl> 0.1292101 #> $ upper  <dbl> 0.1734687 #> $ label  <chr> \"15.0% [12.9% - 17.3%] (150/1000)\""},{"path":"/articles/dispatch.html","id":"grouping-based-dispatch","dir":"Articles","previous_headings":"Dispatch","what":"Grouping based dispatch","title":"Multiple dispatch based on dataframes","text":"often useful function can expects specific grouping can handle additional groups. One way handling use purrr nest columns extensively. Nesting data unexpected groups repeatedly applying function want. alternative dplyr solution use group_modify. interfacer leverages second option automatically determine grouping necessary pipeline function stated grouping requirements automatically handle without additional coding package. example following iface input function must grouped color column: package developer writing pipeline function may use fact handle possible additional grouping using igroup_process(df, ...) pass correctly grouped data conforming i_diamond_price inner function executed transparently, input validated: hand additional groups present inner function executed additional groups. Data validation happens per group, affects interpretation uniqueness. output actually grouped cut color column grouping consumed nested function igroup_process.","code":"i_diamond_price = interfacer::iface(   color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",   price = integer ~ \"the price column\",   .groups = ~ color ) # exported function in package  # at param can use `r idocument(ex_mean, df)` for documentation  ex_mean = function(df = i_diamond_price, extra_param = \".\") {     # dispatch based on groupings:    igroup_process(df,       # the real work of this function is provided as an anonymous inner      # function (but can be any other function e.g. package private function)      # or a purrr style lambda.       function(df, extra_param) {        message(extra_param, appendLF = FALSE)        return(df %>% dplyr::summarise(mean_price = mean(price)))      }     )  } # The correctly grouped dataframe ggplot2::diamonds %>%   dplyr::group_by(color) %>%   ex_mean(extra_param = \"without additional groups...\") %>%   dplyr::glimpse() #> without additional groups... #> Rows: 7 #> Columns: 2 #> $ color      <ord> D, E, F, G, H, I, J #> $ mean_price <dbl> 3169.954, 3076.752, 3724.886, 3999.136, 4486.669, 5091.875,… # The incorrectly grouped dataframe ggplot2::diamonds %>%   dplyr::group_by(cut, color) %>%   ex_mean() %>%   dplyr::glimpse() #> ..... #> Rows: 35 #> Columns: 3 #> Groups: cut [5] #> $ cut        <ord> Fair, Fair, Fair, Fair, Fair, Fair, Fair, Good, Good, Good,… #> $ color      <ord> D, E, F, G, H, I, J, D, E, F, G, H, I, J, D, E, F, G, H, I,… #> $ mean_price <dbl> 4291.061, 3682.312, 3827.003, 4239.255, 5135.683, 4685.446,…"},{"path":"/articles/interfacer.html","id":"rationale","dir":"Articles","previous_headings":"","what":"Rationale","title":"Dataframe validation","text":"interfacer designed support package authors wish use dataframes input parameters package functions. case assumptions structure input dataframe, terms expected column names, expected column data types, expected grouping structure common problem leads lot code validate input detect edge cases grouping, creates requirement detailed documentation nature accepted input dataframes. interfacer provides mechanism simply specifying input dataframe constraints iface specification, one liner validating input, roxygen tag automating documentation dataframe inputs. dissimilar conceptually definition table relational database, specification XML schema. interfacer also provides capabilities support checking dataframe function outputs, dispatching functions based dataframe input structure, flexibly handling unexpectedly grouped data.","code":""},{"path":"/articles/interfacer.html","id":"defining-an-interface","dir":"Articles","previous_headings":"","what":"Defining an interface","title":"Dataframe validation","text":"iface specification defines structure acceptable dataframes. list column names, plus types documentation column. Printing interface specification shows structure iface defines. iface specification associated specific function parameter set default value parameter. dummy default value combined ivalidate function body user supplied dataframe validated ensure right shape. can use @iparam <param> <description> Roxygen skeleton document dataframe constraints. case later call example_fn data checked requirements ivalidate, acceptable passed rest function body (case nothing validated input returned). call function data conforms validation succeeds validated input data returned. noted although passed numeric vector id column function coerced int vector ivalidate. Data type checking interfacer permissive something can coerced without warning . pass non-conformant data ivalidate throws informative error wrong data. case test column missing: can recover error renaming columns passing bad_example_data example_fn(). second example input data frame non-conformant specification id column coerced integer. error aims informative enough user fix problem.","code":"i_test = iface(   id = integer ~ \"an integer ID\",   test = logical ~ \"the test result\" ) cat(print(i_test)) #> A dataframe containing the following columns:  #> * id (integer) - an integer ID #> * test (logical) - the test result #> No mandatory groupings. #> No default value. #' An example function #' #' @iparam mydata a dataframe input which should conform to `i_test` #' @param another an example #' @param ... not used #' #' @return the conformant dataframe #' @export example_fn = function(   mydata = i_test,   another = \"value\",   ... ) {   mydata = ivalidate(mydata)   return(mydata) } example_data = tibble::tibble(     id = c(1,2,3), # this is a numeric vector     test = c(TRUE,FALSE,TRUE)   )  # this returns the qualifying data example_fn(   example_data,    \"value for another\" ) %>% dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ id   <int> 1, 2, 3 #> $ test <lgl> TRUE, FALSE, TRUE bad_example_data = tibble::tibble(     id = c(1,2,3),     wrong_name = c(TRUE,FALSE,TRUE)   )  # this causes an error as example_data_2$wrong_test is wrongly named try(example_fn(   bad_example_data,    \"value for another\" )) #> Error : missing columns in the `mydata` parameter of `example_fn(...)`. #> missing: test #> consider renaming / creating missing columns before calling `example_fn(...)` bad_example_data_2 = tibble::tibble(     id = c(1, 2.1, 3), # cannot be cleanly coerced to integer.     test = c(TRUE,FALSE,TRUE)   )  try(example_fn(   bad_example_data_2,    \"value for another\" )) #> Error : input column `id` in function parameter `example_fn(mydata = ?)` cannot be coerced to a integer: not a true integer input"},{"path":"/articles/interfacer.html","id":"extension-and-composition","dir":"Articles","previous_headings":"","what":"Extension and composition","title":"Dataframe validation","text":"Interface specifications can composed extended. case extension i_test specification can created: extended iface specification adds constraint character column named extra must grouping. used constrain input another example function . also constrain output second function conformant original specification using ireturn. Examples documenting input parameter output parameter provided : case ivalidate call prunes unneeded data dataframe, removing extra columns, also ensures input grouped way. (Grouping described detail .) rejected grouping incorrect. informative error message provided: Following instructions error message makes previously failing data validate i_test_extn:","code":"i_test_extn = iface(   i_test,   extra = character ~ \"a new value\",   .groups = FALSE )  print(i_test_extn) #> A dataframe containing the following columns:  #> * id (integer) - an integer ID #> * test (logical) - the test result #> * extra (character) - a new value #> Ungrouped. #> No default value. #' Another example function  #'  #' @iparam mydata a more constrained input #' @param another an example    #' @param ... not used #' #' @return `r i_test` #' @export example_fn2 = function(     mydata = i_test_extn,     ... ) {   mydata = ivalidate(mydata, ..., .prune = TRUE)   mydata = mydata %>% dplyr::select(-extra)   # check the return value conforms to a new specification   ireturn(mydata, i_test) } grouped_example_data = tibble::tibble(     id = c(1,2,3),     test = c(TRUE,FALSE,TRUE),     extra = c(\"a\",\"b\",\"c\"),     unneeded = c(\"x\",\"y\",\"z\")   ) %>% dplyr::group_by(id) try(example_fn2(grouped_example_data)) #> Error : unexpected additional groups in `mydata` parameter of `example_fn2(...)` #> additional: id #> consider regrouping your data before calling function `example_fn2(...)`, e.g.: #> `df %>% ungroup() %>% example_fn2(...)` #> or calling function `example_fn2(...)` using a group_modify, e.g.: #> `df %>% group_by(id) %>% group_modify(example_fn2, ...)` grouped_example_data %>%    dplyr::ungroup() %>%    example_fn2() %>%    dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ id   <int> 1, 2, 3 #> $ test <lgl> TRUE, FALSE, TRUE"},{"path":"/articles/interfacer.html","id":"grouping","dir":"Articles","previous_headings":"","what":"Grouping","title":"Dataframe validation","text":"Unanticipated grouping common cause unexpected behaviour functions operate dataframes. interfacer can also specify degree grouping expected. can take form constraints ) enforce grouping present, b) enforce dataframe grouped exactly given set columns, c) enforce data frame grouped least given set columns (possibly ). iface specification can permissive dogmatic grouping input. .groups option iface specification NULL (e.g. iface(..., .groups=NULL)) grouping allowed. FALSE grouping allowed. third option supply one sided formula. case variables formula define grouping must exactly present, e.g. ~ grp1 + grp2, also includes ., additional grouping also permitted (e.g. ~ . + grp1 + grp2). permissive form allow grouping df %>% group_by(anything, grp1, grp2). group column specified must present, regardless rest iface specification. example cut column required i_diamonds contract data type specified. Rather create third example function example used iconvert interactive ivalidate.","code":"i_diamonds = interfacer::iface(     carat = numeric ~ \"the carat column\",     color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",     x = numeric ~ \"the x column\",     y = numeric ~ \"the y column\",     z = numeric ~ \"the z column\",     # This specifies a permissive grouping with at least `carat` and `cut` columns     .groups = ~ . + carat + cut )  if (rlang::is_installed(\"ggplot2\")) {      # permissive grouping with the `~ . + carat + cut` groups rule   ggplot2::diamonds %>%      dplyr::group_by(color, carat, cut) %>%      # in a usual workflow this would be an `ivalidate` call within a package      # function but for this example we are directly calling the underlying function     # `iconvert`     iconvert(i_diamonds, .prune = TRUE) %>%      dplyr::glimpse()  } #> Rows: 53,940 #> Columns: 6 #> Groups: color, carat, cut [4,803] #> $ color <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I, E… #> $ carat <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.30… #> $ cut   <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Very … #> $ x     <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.25… #> $ y     <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.28… #> $ z     <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.73…"},{"path":"/articles/interfacer.html","id":"documentation","dir":"Articles","previous_headings":"","what":"Documentation","title":"Dataframe validation","text":"roxygen block documentation second interface determined #' @iparam block, uses underlying function idocument. Demonstrating behaviour @iparam roxygen tag hard vignette essentially inserts following block documentation devtools::document called:","code":"cat(idocument(example_fn2)) #> A dataframe containing the following columns:  #>  #> * id (integer) - an integer ID #> * test (logical) - the test result #> * extra (character) - a new value #>  #> Ungrouped. #>  #> No default value."},{"path":"/articles/interfacer.html","id":"type-coercion","dir":"Articles","previous_headings":"","what":"Type coercion","title":"Dataframe validation","text":"interfacer implement rigid type system, rather permissive one. provided data can coerced specified type without major loss automatically done, long can proceed warnings. example id (expected int) provided character extra (expected character) coerced provided numeric. Completely incorrect data types hand picked rejected. case data supplied id cast integer without loss. Similar behaviour seen logical data anything 0 1 example. Factors might allowable levels well. define enum accepts list values, must matched levels provided factor. order levels taken iface specification re-levelling inputs taken ensure factor levels match specification. .drop = TRUE specified values don’t match levels cast NA rather causing failure allow conformance subset factor values.","code":"tibble::tibble(   id=c(\"1\",\"2\",\"3\"),   test = c(TRUE,FALSE,TRUE),   extra = 1.1 ) %>% example_fn2() %>%  dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ id   <int> 1, 2, 3 #> $ test <lgl> TRUE, FALSE, TRUE try(example_fn(   tibble::tibble(     id= c(\"1.1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE)   ))) #> Error : input column `id` in function parameter `example_fn(mydata = ?)` cannot be coerced to a integer: not a true integer input if (rlang::is_installed(\"ggplot2\")) {      i_diamonds = iface(      color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",     cut = enum(Ideal, Premium, .drop=TRUE) ~ \"the cut\",     price = integer ~ \"the price\"   )      ggplot2::diamonds %>%      iconvert(i_diamonds, .prune = TRUE) %>%      dplyr::glimpse()     }  #> Rows: 53,940 #> Columns: 3 #> $ color <fct> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I, E… #> $ cut   <fct> Ideal, Premium, NA, Premium, NA, NA, NA, NA, NA, NA, NA, Ideal, … #> $ price <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 342,…"},{"path":"/articles/interfacer.html","id":"more-complex-type-constraints","dir":"Articles","previous_headings":"","what":"More complex type constraints","title":"Dataframe validation","text":"type dataframe column can defined basic datatype, however complex constraints also available provided interfacer. can listed searching help system ??interfacer::type. console. individual help files functions explain use iface specification used left hand side formula can composed allow multiple constraints. example: Column wise default values can supplied default(...) pseudo-function ranges in_range(...). documentation available ?interfacer::type.default ?interfacer::type.in_range. can noted although internal functions prefixed type.XXX, prefix needed iface specification. also theoretically possible supply checks specification. must form function accepts one vector input produces one vector output, throws error example. N.B. using custom conditions within package must visible interfacer normally means need exported may need referred package prefix. final option use .XXX function condition. example define column POSIXct type, second column defined ts class vector:","code":"iface(   col1 = double + finite ~ \"A finite double\",   col2 = integer + in_range(0,100) ~ \"an integer in the range 0 to 100 inclusive\",   col3 = numeric + in_range(0,10, include.max=FALSE) ~ \"a numeric 0 <= x < 10\",    col4 = date ~ \"A date\",   col5 = logical + not_missing ~ \"A non-NA logical\",   col6 = logical + default(TRUE) ~ \"A logical with missing (i.e. NA) values coerced to TRUE\",   col7 = factor ~ \"Any factor\",   col8 = enum(`A`,`B`,`C`) + not_missing ~ \"A factor with exactly 3 levels A, B and C and no NA values\" ) uppercase = function(x) {   if (any(x != toupper(x))) stop(\"not upper case input\",call. = FALSE)   return(x) }  custom_eg = function(df = iface(   text = character + uppercase ~ \"An uppercase input only\" )) {   df = ivalidate(df)   return(df) }  tibble::tibble(text = \"SUCCESS\") %>% custom_eg() #> # A tibble: 1 × 1 #>   text    #>   <chr>   #> 1 SUCCESS  try(tibble::tibble(text = \"fail\") %>% custom_eg()) #> Error : input column `text` in function parameter `custom_eg(df = ?)` cannot be coerced to a character + uppercase: not upper case input # Coerce the `date_col` to a POSIXct and  custom_eg_2 = function( df = iface(     date_col = POSIXct ~ \"a posix date\",     ts_col = of_type(ts) ~ \"A timeseries vector\"   )) {   df = ivalidate(df)   return(lapply(df, class)) }  tibble::tibble(   date_col = c(\"2001-01-01\",\"2002-01-01\"),   ts_col = ts(c(2,1)) ) %>% custom_eg_2() #> $date_col #> [1] \"POSIXct\" \"POSIXt\"  #>  #> $ts_col #> [1] \"ts\""},{"path":"/articles/interfacer.html","id":"default-dataframe-values","dir":"Articles","previous_headings":"","what":"Default dataframe values","title":"Dataframe validation","text":"interfacer hijacks R default value function parameter define input dataframe constraints, needs alternative way supply default value one needed. iface specification can define default. can either ) zero length dataframe, b) dataframe supplied time interface definition, c) data frame supplied time function execution. get zero length dataframe default value TRUE passed .default value iface: second example default value specified interface specification. third example override default per function basis supplying default ivalidate within function body. case default just first 5 rows:","code":"i_iris = interfacer::iface(     Sepal.Length = numeric ~ \"the Sepal.Length column\",     Sepal.Width = numeric ~ \"the Sepal.Width column\",     Petal.Length = numeric ~ \"the Petal.Length column\",     Petal.Width = numeric ~ \"the Petal.Width column\",     Species = enum(`setosa`,`versicolor`,`virginica`) ~ \"the Species column\",     .groups = NULL,   .default = TRUE )  test_fn = function(i = i_iris, ...) {   # if i is not provided (a missing value) the default zero length    # dataframe defined by `i_iris` is used.   i = ivalidate(i)   return(i) }  # Outputs a zero length data frame as the default value test_fn() %>% dplyr::glimpse() #> Rows: 0 #> Columns: 5 #> $ Sepal.Length <dbl>  #> $ Sepal.Width  <dbl>  #> $ Petal.Length <dbl>  #> $ Petal.Width  <dbl>  #> $ Species      <fct> i_iris_2 = interfacer::iface(     Sepal.Length = numeric ~ \"the Sepal.Length column\",     Sepal.Width = numeric ~ \"the Sepal.Width column\",     Petal.Length = numeric ~ \"the Petal.Length column\",     Petal.Width = numeric ~ \"the Petal.Width column\",     Species = enum(`setosa`,`versicolor`,`virginica`) ~ \"the Species column\",     .groups = NULL,   .default = iris )  test_fn_2 = function(i = i_iris_2, ...) {   i = ivalidate(i)   return(i) }  # Outputs the 150 row iris data frame as a default value from the definition of `i_iris_2` test_fn_2() %>% dplyr::glimpse() #> Rows: 150 #> Columns: 5 #> $ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.… #> $ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.… #> $ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.… #> $ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.… #> $ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s… test_fn_3 = function(i = i_iris_2, ...) {   i = ivalidate(i, .default = iris %>% head(5))   return(i) }  # Outputs the first 5 rows of the iris data frame as the default value test_fn_3() %>% dplyr::glimpse() #> Rows: 5 #> Columns: 5 #> $ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0 #> $ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6 #> $ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4 #> $ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2 #> $ Species      <fct> setosa, setosa, setosa, setosa, setosa"},{"path":"/articles/interfacer.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Dataframe validation","text":"vignette covers primary validation functions interfacer, including missing columns, datatype checks enforcing grouping structure. Automation documentation interface composition also covered. Please see vignettes topics function dispatch based iface specifications, automatically handling grouped input, nesting purrr style list columns, quick summary tools help developers.","code":""},{"path":"/articles/nesting.html","id":"nesting-list-columns","dir":"Articles","previous_headings":"","what":"Nesting & list columns","title":"Nested dataframes and `purrr` style list columns","text":"interfacer designed work list columns, generated purrr. purrr style list columns may contain arbitrary data type within list. Consider following complex dataframe example, includes single regular factor column, nested dataframe list column, nested S3 lm object list column nested matrix list column: interfacer can used represent validate data structure. initial specifications generated using iclip(tmp) hand modified: can test input matches specification: specifications used validation, controlling function dispatch. However must recognised validation nested dataframes potentially computationally expensive individual nested dataframe must completely validated. create high overhead situations large number small nested dataframes. Another example nested list column using diamonds dataframe demonstrates overhead, 276 nested dataframes need validated individually. takes seconds machine. example price column removes nesting. Errors validation nested columns bubbled top level.","code":"tmp = iris %>%    tidyr::nest(by_species = -Species) %>%   dplyr::mutate(     model = purrr::map(by_species, ~ stats::lm(Sepal.Length ~ Sepal.Width, .x)),     quantiles = purrr::map(by_species, ~ sapply(.x, quantile))   )  tmp %>% dplyr::glimpse() #> Rows: 3 #> Columns: 4 #> $ Species    <fct> setosa, versicolor, virginica #> $ by_species <list> [<tbl_df[50 x 4]>], [<tbl_df[50 x 4]>], [<tbl_df[50 x 4]>] #> $ model      <list> [2.6390012, 0.6904897, 0.04428474, 0.18952960, -0.14856834,… #> $ quantiles  <list> <<matrix[5 x 4]>>, <<matrix[5 x 4]>>, <<matrix[5 x 4]>> # Pasted from `iclip(tmp)` with minor modification: i_tmp = interfacer::iface(     Species = enum(`setosa`,`versicolor`,`virginica`) ~ \"the Species column\",     by_species = list(i_by_species) ~ \"the by_species column\",     model = list(of_type(lm)) ~ \"the model column\",     quantiles = list(matrix) ~ \"the quantiles column\",     .groups = NULL )  i_by_species = interfacer::iface(     Sepal.Length = numeric ~ \"the Sepal.Length column\",     Sepal.Width = numeric ~ \"the Sepal.Width column\",     Petal.Length = numeric ~ \"the Petal.Length column\",     Petal.Width = numeric ~ \"the Petal.Width column\",     .groups = NULL ) tmp %>% iconvert(i_tmp) %>% dplyr::glimpse() #> Rows: 3 #> Columns: 4 #> $ Species    <fct> setosa, versicolor, virginica #> $ by_species <list> [<tbl_df[50 x 4]>], [<tbl_df[50 x 4]>], [<tbl_df[50 x 4]>] #> $ model      <list> [2.6390012, 0.6904897, 0.04428474, 0.18952960, -0.14856834,… #> $ quantiles  <list> <<matrix[5 x 4]>>, <<matrix[5 x 4]>>, <<matrix[5 x 4]>> i_diamonds_cat = interfacer::iface(   cut = enum(`Fair`,`Good`,`Very Good`,`Premium`,`Ideal`, .ordered=TRUE) ~ \"the cut column\",   color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",   clarity = enum(`I1`,`SI2`,`SI1`,`VS2`,`VS1`,`VVS2`,`VVS1`,`IF`, .ordered=TRUE) ~ \"the clarity column\",   data = list(i_diamonds_data) ~ \"A nested data column must be specified as a list\",   .groups = FALSE )  i_diamonds_data = interfacer::iface(   carat = numeric ~ \"the carat column\",   depth = numeric ~ \"the depth column\",   table = numeric ~ \"the table column\",   price = integer ~ \"the price column\",   x = numeric ~ \"the x column\",   y = numeric ~ \"the y column\",   z = numeric ~ \"the z column\",   .groups = FALSE )  nested_diamonds = ggplot2::diamonds %>%   tidyr::nest(data = c(-cut,-color,-clarity))  system.time(   nested_diamonds %>%      iconvert(i_diamonds_cat) %>%      dplyr::glimpse() ) #> Rows: 276 #> Columns: 4 #> $ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver… #> $ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, I, E, G,… #> $ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, … #> $ data    <list> [<tbl_df[469 x 7]>], [<tbl_df[614 x 7]>], [<tbl_df[89 x 7]>],… #>    user  system elapsed  #>   2.703   0.006   2.710 try(   ggplot2::diamonds %>%     dplyr::select(-price) %>%     tidyr::nest(data = c(-cut,-color,-clarity)) %>%     iconvert(i_diamonds_cat) %>%      dplyr::glimpse() ) #> Error : input column `data` in function parameter `<unknown>(<unknown> = ?)` cannot be coerced to a list(i_diamonds_data): nested dataframe problem - missing columns: price"},{"path":"/articles/nesting.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Nested dataframes and `purrr` style list columns","text":"interfacer work nested dataframes performance hit nested columns iface specifications. Care must taken capability used keep data validation performant.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robert Challen. Author, maintainer, copyright holder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2024). interfacer: Define Enforce Interface Contracts Dataframe Parameters. R package version 0.2.1,  https://github.com/bristol-vaccine-centre/interfacer, https://bristol-vaccine-centre.github.io/interfacer/.","code":"@Manual{,   title = {interfacer: Define and Enforce Interface Contracts for Dataframe Parameters},   author = {Robert Challen},   year = {2024},   note = {R package version 0.2.1,  https://github.com/bristol-vaccine-centre/interfacer},   url = {https://bristol-vaccine-centre.github.io/interfacer/}, }"},{"path":"/index.html","id":"interfacer","dir":"","previous_headings":"","what":"Define and Enforce Interface Contracts for Dataframe Parameters","title":"Define and Enforce Interface Contracts for Dataframe Parameters","text":"interfacer primarily aimed R package developers. provides framework specifying structure dataframes parameters user functions checking user supplied dataframes conform expectations. Missing columns incorrectly typed columns can identified useful error messages returned. Specifying structure part function definition can automatically included Roxygen documentation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Define and Enforce Interface Contracts for Dataframe Parameters","text":"can install released version interfacer CRAN : likely though including another package via DESCRIPTION file: development versions package hosted Bristol Vaccine Centre r-universe. Installation follows: via DESCRIPTION file: can also install development version interfacer GitHub :","code":"install.packages(\"interfacer\") ... Imports:      tidyverse,     interfacer Suggests:      knitr,     rmarkdown ... options(repos = c(   \"bristol-vaccine-centre\" = 'https://https://bristol-vaccine-centre.r-universe.dev/',   CRAN = 'https://cloud.r-project.org'))  # Download and install interfacer in R install.packages(\"interfacer\") ... Imports:      tidyverse,     interfacer Remotes: github::bristol-vaccine-centre/interfacer Suggests:      knitr,     rmarkdown ... # install.packages(\"devtools\") devtools::install_github(\"bristol-vaccine-centre/interfacer\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Define and Enforce Interface Contracts for Dataframe Parameters","text":"interfacer used within function definition package constrain input function particular shape. @iparam annotation generate documentation explains expected dataframe format. calling function, column name, data type grouping structure checks made input informative errors thrown input incorrectly specified. interfacer also includes tools help developers adopt iface specifications generating example data, documenting dataframes bundled package.","code":"#' An example function #' #' @iparam mydata a test dataframe input parameter #' @param another an example other input parameter   #' @param ... not used #' #' @return ... something not yet defined ... #' @export example_fn = function(      # this parameter will be a dataframe with id and test columns   # id will be a unique integer, and test a logical value   mydata = interfacer::iface(     id = integer + group_unique ~ \"an integer ID\",     test = logical + default(FALSE) ~ \"the test result\"   ),      another = \"value\",   ...    ) {      # this line enforces the `iface` rules for the dataframe, coercing columns   # if possible and throwing helpful errors if not.   mydata = interfacer::ivalidate(mydata, ...)      # rest of function body can use `mydata` in the certain knowledge that   # id is a unique integer and test is a logical value... }"},{"path":"/reference/as.list.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast an iface to a plain list. — as.list.iface","title":"Cast an iface to a plain list. — as.list.iface","text":"Cast iface plain list.","code":""},{"path":"/reference/as.list.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast an iface to a plain list. — as.list.iface","text":"","code":"# S3 method for iface as.list(x, ..., flatten = FALSE)"},{"path":"/reference/as.list.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast an iface to a plain list. — as.list.iface","text":"x object coerced tested. ... objects, possibly named. flatten get list lists representation instead dataframe column column list.","code":""},{"path":"/reference/as_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"Reuse tidy-select syntax outside tidy-select function","code":""},{"path":"/reference/as_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"","code":"as_vars(tidyselect, data = NULL)"},{"path":"/reference/as_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"tidyselect tidyselect syntax evaluated context looking call call stack includes dataframe first argument data (optional) specific dataframe evaluate tidyselect","code":""},{"path":"/reference/as_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"list symbols resulting evaluation tidyselect context current call stack (provided data frame)","code":""},{"path":"/reference/enum.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to match a factor with specific levels. — enum","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"Define conformance rule match factor specific levels.","code":""},{"path":"/reference/enum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"","code":"enum(..., .drop = FALSE)"},{"path":"/reference/enum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"... levels (quotes, backticks required) .drop levels present data specified cause error (FALSE default) silently dropped NA values (TRUE).","code":""},{"path":"/reference/enum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"function can check convert input factor specified levels. re-level factors matching levels different order.","code":""},{"path":"/reference/enum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"","code":"f = enum(one,two,three) f(c(\"three\",\"two\",\"one\")) #> [1] three two   one   #> Levels: one two three f(factor(rep(1:3,5), labels = c(\"one\",\"two\",\"three\"))) #>  [1] one   two   three one   two   three one   two   three one   two   three #> [13] one   two   three #> Levels: one two three"},{"path":"/reference/format.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Format an iface specification for printing — format.iface","title":"Format an iface specification for printing — format.iface","text":"Format iface specification printing","code":""},{"path":"/reference/format.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format an iface specification for printing — format.iface","text":"","code":"# S3 method for iface format(x, ...)"},{"path":"/reference/format.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format an iface specification for printing — format.iface","text":"x iface specification ... used.","code":""},{"path":"/reference/format.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format an iface specification for printing — format.iface","text":"","code":"my_iface = iface(    col1 = integer + group_unique ~ \"an integer column\" )  print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> No mandatory groupings. #> No default value. knitr::knit_print(my_iface) #> [1] \"A dataframe containing the following columns: \\n\\n* col1 (integer + group_unique) - an integer column\\n\\nNo mandatory groupings.\\n\\nNo default value.\" #> attr(,\"class\") #> [1] \"knit_asis\""},{"path":"/reference/iclip.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an iface specification from an example dataframe — iclip","title":"Create an iface specification from an example dataframe — iclip","text":"developing interfacer useful able base function input prototype example using testing. function generates interfacer::iface specification supplied data frame copies  clipboard can pasted package code working .","code":""},{"path":"/reference/iclip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an iface specification from an example dataframe — iclip","text":"","code":"iclip(df, df_name = deparse(substitute(df)))"},{"path":"/reference/iclip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an iface specification from an example dataframe — iclip","text":"df prototype dataframe df_name optional name parameter (defaults i_<df name>)","code":""},{"path":"/reference/iclip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an iface specification from an example dataframe — iclip","text":"nothing, populates clipboard","code":""},{"path":"/reference/iclip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an iface specification from an example dataframe — iclip","text":"dataframe contains one list columns nested dataframes nested dataframes also defined using second iface specification.","code":""},{"path":"/reference/iclip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an iface specification from an example dataframe — iclip","text":"","code":"if(FALSE) iclip(iris)"},{"path":"/reference/iconvert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dataframe to a format compatible with an interface specification — iconvert","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"function called ivalidate generally intended used directly end user. may helpful debugging package development interactive test iface spec. iconvert interactive version ivalidate.","code":""},{"path":"/reference/iconvert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"","code":"iconvert(   df,   iface,   .imap = interfacer::imapper(),   .dname = \"<unknown>\",   .fname = \"<unknown>\",   .has_dots = TRUE,   .prune = FALSE,   .env = rlang::current_env() )"},{"path":"/reference/iconvert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"df dataframe convert iface interface spec iface .imap optional imapper mapping .dname name parameter value (optional). .fname name function (optional). .has_dots internal library use . Changes nature error message. .prune want remove non matching columns? .env internal use ","code":""},{"path":"/reference/iconvert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"input dataframe coerced conformant iface specification, informative error thrown.","code":""},{"path":"/reference/iconvert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"","code":"i_diamonds = iface(    color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",    price = integer ~ \"the price\" )  iconvert(ggplot2::diamonds, i_diamonds,.prune = TRUE) #> # A tibble: 53,940 × 2 #>    color price #>    <fct> <int> #>  1 E       326 #>  2 E       326 #>  3 E       327 #>  4 I       334 #>  5 J       335 #>  6 J       336 #>  7 I       336 #>  8 H       337 #>  9 E       337 #> 10 H       338 #> # ℹ 53,930 more rows"},{"path":"/reference/idispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"provides dataframe analogy S3 dispatch.","code":""},{"path":"/reference/idispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"","code":"idispatch(x, ..., .default = NULL)"},{"path":"/reference/idispatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"x dataframe ... set function name=interfacer::iface pairs .default function apply situation none rules can matched. default results error thrown.","code":""},{"path":"/reference/idispatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"result dispatching dataframe first function matches rules .... Matching permissive test passed dataframe can coerced iface specified format.","code":""},{"path":"/reference/idispatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"multiple possible dataframe formats possible function, different processing requirements, choice function can made based matching input dataframe set iface specifications. first matching iface specification determines function used dispatch.","code":""},{"path":"/reference/idispatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"","code":"i1 = iface( col1 = integer ~ \"An integer column\" ) i2 = iface( col2 = integer ~ \"A different integer column\" )  # this is an example function that would typically be inside a package, and # is exported from the package. extract_mean = function(df, ...) {   idispatch(df,     extract_mean.i1 = i1,     extract_mean.i2 = i2   ) }  # this is expected to be an internal package function # the naming convention here is based on S3 but it is not required extract_mean.i1 = function(df = i1, ...) {   message(\"using i1\")   # input validation is not required in functions that are being called using   # `idispatch` as the validation occurs during dispatch.    mean(df$col1) }  extract_mean.i2 = function(df = i2, uplift = 1, ...) {   message(\"using i2\")   mean(df$col2)+uplift }  # this input matches `i1` and the `extract_mean` call is dispatched  # via `extract_mean.i1` test = tibble::tibble( col2 = 1:10 ) extract_mean(test, uplift = 50) #> using i2 #> [1] 55.5  # this input matches `i2` and the `extract_mean` call is dispatched  # via `extract_mean.i2` test2 = tibble::tibble( col1 = 1:10 ) extract_mean(test2, uplift = 50) #> using i1 #> [1] 5.5  # This input does not match any of the allowable input specifications and  # generates an error. test3 = tibble::tibble( wrong_col = 1:10 ) try(extract_mean(test3, uplift = 50)) #> Error : the parameter in extract_mean(...) does not match any of the expected formats. #> extract_mean.i1 - Error : missing columns: col1 #> extract_mean.i2 - Error : missing columns: col2 #>"},{"path":"/reference/idocument.html","id":null,"dir":"Reference","previous_headings":"","what":"Document an interface contract for inserting into roxygen — idocument","title":"Document an interface contract for inserting into roxygen — idocument","text":"function expected called within documentation function inline code parameter documentation function. details expected columns input dataframe possess. mostly superceded @iparam <name> <description> roxygen tag automatically, however circumstances (particularly muliple dispatch) may want assemble dataframe documentation manually.","code":""},{"path":"/reference/idocument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Document an interface contract for inserting into roxygen — idocument","text":"","code":"idocument(fn, param = NULL)"},{"path":"/reference/idocument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Document an interface contract for inserting into roxygen — idocument","text":"fn function documenting param parameter documenting (optional. missing defaults first argument function)","code":""},{"path":"/reference/idocument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Document an interface contract for inserting into roxygen — idocument","text":"markdown snippet","code":""},{"path":"/reference/idocument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Document an interface contract for inserting into roxygen — idocument","text":"","code":"#' @param df `r idocument(x, df)` x = function(df = iface( col1 = integer ~ \"an integer column\" )) {}  cat(idocument(x, df)) #> A dataframe containing the following columns:  #>  #> * col1 (integer) - an integer column #>  #> No mandatory groupings. #>  #> No default value."},{"path":"/reference/if_col_present.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a function or return a value if a column in present in a dataframe — if_col_present","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"simple use case. complex behaviour see switch_pipeline().","code":""},{"path":"/reference/if_col_present.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"","code":"if_col_present(df, col, if_present, if_missing = ~.x)"},{"path":"/reference/if_col_present.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"df dataframe col column name if_present purrr style function execute dataframe column present (plain value) if_missing purrr style function execute dataframe column missing (plain value)","code":""},{"path":"/reference/if_col_present.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"either value if_present/if_absent result calling if_present/if_absent functions df.","code":""},{"path":"/reference/if_col_present.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"","code":"iris %>% if_col_present(Species, ~ .x %>% dplyr::rename(new = Species)) %>%   colnames() #> [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"new\"           # in contrast to purrr absolute values are not interpreted as function names   iris %>% if_col_present(Species2, \"Yes\", \"No\") #> [1] \"No\""},{"path":"/reference/iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an interface specification — iface","title":"Construct an interface specification — iface","text":"iface specification defines expected structure dataframe, terms column names, column types, grouping structure uniqueness constraints dataframe must conform . dataframe can tested conformance iface specification using iconvert.","code":""},{"path":"/reference/iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an interface specification — iface","text":"","code":"iface(..., .groups = NULL, .default = NULL)"},{"path":"/reference/iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an interface specification — iface","text":"... specification interface (see details), unnamed iface object extend, . .groups either FALSE grouping allowed formula form ~ var1 + var2 + ... defines columns must grouped dataframe (order). NULL (default) grouping permitted. formula contains dot e.g. ~ . + var1 + var2 grouping must include var1 var2 groups also allowed. .default default value supply nothing given function parameter using iface formal. either NULL case default, TRUE case default zero row tibble conforming spec, provided dataframe, checked conform, used default.","code":""},{"path":"/reference/iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an interface specification — iface","text":"definition interface iface object","code":""},{"path":"/reference/iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct an interface specification — iface","text":"iface specification designed used define type parameter function. done using iface specification default value parameter function definition. definition can validated runtime call ivalidate(...) inside function. developing function output iface specification may also used ireturn(...) enforce output function correct. iface definitions can printed included roxygen documentation help us document input dataframe parameters dataframe return values standardised way using @iparam roxygen tag. iface specifications defined form named list formulae structure column_name = type ~ \"documentation\". type can one anything, character, complete, date, default, double, enum, factor, finite, group_unique, in_range, integer, logical, not_missing, numeric, of_type, positive_double, positive_integer, proportion (e.g. enum(level1,level2,...), in_range(min,max)) alternatively anything resolves function e.g. .ordered. type function name, function must take single vector parameter return single vector size. function must also return zero length vector appropriate type passed NULL. type can also concatenation rules separated +, e.g. integer + group_unique integer unique within group.","code":""},{"path":"/reference/iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct an interface specification — iface","text":"","code":"test_df = tibble::tibble(   grp = c(rep(\"a\",10),rep(\"b\",10)),    col1 = c(1:10,1:10) ) %>% dplyr::group_by(grp)  my_iface = iface(    col1 = integer + group_unique ~ \"an integer column\",   .default = test_df )  print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> No mandatory groupings. #> A default value is defined.  # the function x defines a formal `df` with default value of `my_iface` # this default value is used to validate the structure of the user supplied # value when the function is called. x = function(df = my_iface, ...) {   df = ivalidate(df,...)   return(df) }  # this works x(tibble::tibble(col1 = c(1,2,3))) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3  # this fails as x is of the wrong type try(x(tibble::tibble(col1 = c(\"a\",\"b\",\"c\")))) #> Error : input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer + group_unique: NAs introduced by coercion  # this fails as x has duplicates try(x(tibble::tibble(col1 = c(1,2,3,3)))) #> Error : input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer + group_unique: values are not unique within each group; check grouping is correct  # this gives the default value x() #> # A tibble: 20 × 2 #> # Groups:   grp [2] #>    grp    col1 #>    <chr> <int> #>  1 a         1 #>  2 a         2 #>  3 a         3 #>  4 a         4 #>  5 a         5 #>  6 a         6 #>  7 a         7 #>  8 a         8 #>  9 a         9 #> 10 a        10 #> 11 b         1 #> 12 b         2 #> 13 b         3 #> 14 b         4 #> 15 b         5 #> 16 b         6 #> 17 b         7 #> 18 b         8 #> 19 b         9 #> 20 b        10   my_iface2 = iface(   first_col = numeric ~ \"column order example\",   my_iface,    last_col = character ~ \"another col\", .groups = ~ first_col + col1 ) print(my_iface2) #> A dataframe containing the following columns:  #> * first_col (numeric) - column order example #> * col1 (integer + group_unique) - an integer column #> * last_col (character) - another col #> Must be grouped by: first_col + col1 (exactly). #> No default value.    my_iface_3 = iface(    col1 = integer + group_unique ~ \"an integer column\",   .default = test_df_2 ) x = function(d = my_iface_3) {ivalidate(d)}  # Doesn't work as test_df_2 hasn't been defined try(x()) #> Error in eval(ex, env) : object 'test_df_2' not found  test_df_2 = tibble::tibble(   grp = c(rep(\"a\",10),rep(\"b\",10)),    col1 = c(1:10,1:10) ) %>% dplyr::group_by(grp)  # now it works as has been defined x() #> # A tibble: 20 × 2 #> # Groups:   grp [2] #>    grp    col1 #>    <chr> <int> #>  1 a         1 #>  2 a         2 #>  3 a         3 #>  4 a         4 #>  5 a         5 #>  6 a         6 #>  7 a         7 #>  8 a         8 #>  9 a         9 #> 10 a        10 #> 11 b         1 #> 12 b         2 #> 13 b         3 #> 14 b         4 #> 15 b         5 #> 16 b         6 #> 17 b         7 #> 18 b         8 #> 19 b         9 #> 20 b        10  # it still works as default has been cached. rm(test_df_2) x() #> # A tibble: 20 × 2 #> # Groups:   grp [2] #>    grp    col1 #>    <chr> <int> #>  1 a         1 #>  2 a         2 #>  3 a         3 #>  4 a         4 #>  5 a         5 #>  6 a         6 #>  7 a         7 #>  8 a         8 #>  9 a         9 #> 10 a        10 #> 11 b         1 #> 12 b         2 #> 13 b         3 #> 14 b         4 #> 15 b         5 #> 16 b         6 #> 17 b         7 #> 18 b         8 #> 19 b         9 #> 20 b        10"},{"path":"/reference/igroup_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle unexpected additional grouping structure — igroup_process","title":"Handle unexpected additional grouping structure — igroup_process","text":"function designed used package author within enclosing function. enclosing function assumed take input dataframe iface specified dataframe.","code":""},{"path":"/reference/igroup_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle unexpected additional grouping structure — igroup_process","text":"","code":"igroup_process(df = NULL, fn, ...)"},{"path":"/reference/igroup_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle unexpected additional grouping structure — igroup_process","text":"df dataframe enclosing function grouping may may correctly supplied. fn function call correctly grouped dataframe specified iface enclosing function. ... passed onto iconvert used supply .prune parameters. triple dot parameters enclosing function separately handled automatically passed fn general passed igroup_process intermediary although probably hurt. behaviour similar NextMethod S3 method dispatch.","code":""},{"path":"/reference/igroup_process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle unexpected additional grouping structure — igroup_process","text":"result calling fn(df, ...) unexpected group","code":""},{"path":"/reference/igroup_process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handle unexpected additional grouping structure — igroup_process","text":"function detects grouping input additional groups specification intercepts , regrouping dataframe applying fn groupwise using equivalent dplyr::group_modify. parameters provided enclosing function passed fn compatible method signatures.","code":""},{"path":"/reference/igroup_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle unexpected additional grouping structure — igroup_process","text":"","code":"# This specification requires that the dataframe is grouped only by the color # column i_diamond_price = interfacer::iface(   color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",   price = integer ~ \"the price column\",   .groups = ~ color )  # An example function which would be exported in a package ex_mean = function(df = i_diamond_price, extra_param = \".\") {      # When called with a dataframe with extra groups `igroup_process` will    # regroup the dataframe according to the structure    # defined for `i_diamond_price` and apply the inner function to each group   # after first calling `ivalidate` on each group.      igroup_process(df,           # the real work of this function is provided as an anonymous inner     # function (but can be any other function e.g. package private function)     # or a purrr style lambda.          function(df, extra_param) {       message(extra_param, appendLF = FALSE)       return(df %>% dplyr::summarise(mean_price = mean(price)))     }        ) }  # The correctly grouped dataframe. The `ex_mean` function calculates the mean # price for each `color` group. ggplot2::diamonds %>%    dplyr::group_by(color) %>%    ex_mean(extra_param = \"without additional groups...\") %>%    dplyr::glimpse() #> without additional groups... #> Rows: 7 #> Columns: 2 #> $ color      <ord> D, E, F, G, H, I, J #> $ mean_price <dbl> 3169.954, 3076.752, 3724.886, 3999.136, 4486.669, 5091.875,…    # If an additionally grouped dataframe is provided by the user. The `ex_mean`  # function calculates the mean price for each `cut`,`clarity`, and `color`  # combination.  ggplot2::diamonds %>%    dplyr::group_by(cut, color, clarity) %>%    ex_mean() %>%    dplyr::glimpse() #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> Rows: 276 #> Columns: 4 #> Groups: cut, clarity [40] #> $ cut        <ord> Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair,… #> $ clarity    <ord> I1, I1, I1, I1, I1, I1, I1, SI2, SI2, SI2, SI2, SI2, SI2, S… #> $ color      <ord> D, E, F, G, H, I, J, D, E, F, G, H, I, J, D, E, F, G, H, I,… #> $ mean_price <dbl> 7383.000, 2095.222, 2543.514, 3187.472, 4212.962, 3501.000,…    # The output of this is actually grouped by cut then clarity as # color is consumed by the igroup_dispatch summarise."},{"path":"/reference/imap.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify mappings that can make dataframes compatible with an interface — imap","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"function expected used .imap = imap(...) context overcome mapping issues","code":""},{"path":"/reference/imap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"imap(...)"},{"path":"/reference/imap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"... set dplyr::mutate() specifications applied dataframe rename otherwise fix missing columns","code":""},{"path":"/reference/imap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"set mappings","code":""},{"path":"/reference/imap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...) } input=tibble::tibble(col2 = c(1,2,3))  # This fails because col1 is missing try(x(input)) #> Error in iconvert(df, spec, .imap, dname, .get_fn_name(fn), .has_dots,  :  #>   1 missing columns in parameter `df` in call to x(...) #> consider renaming to create `col1` columns #> or by adding `.imap = interfacer::imap(`col1` = ???)` to your function call. #>  # This fixes it for this input x(input, .imap=imap(col1 = col2))"},{"path":"/reference/imapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","title":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","text":"function uses ivalidate internally check dataframe conforms input can attempt rescue incorrectly formatted dataframe. pretty advanced idea generally recommended.","code":""},{"path":"/reference/imapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","text":"","code":"imapper(...)"},{"path":"/reference/imapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","text":"... set dplyr::mutate() specifications applied dataframe rename otherwise fix missing columns","code":""},{"path":"/reference/imapper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","text":"set mappings","code":""},{"path":"/reference/imapper.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","text":"function expected used context .imap = imapper(...) parameter ivalidate call make sure certain columns present set value. Anything provided overwrite existing dataframe columns use likely make function behaviour obtuse. may deprecated future. ... input expressions almost certainly check values already existing overwriting . considering using replacing missing values check using default(...) iface type definition instead.","code":""},{"path":"/reference/imapper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify mappings that can make dataframes compatible with an iface specfication — imapper","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...) } input=tibble::tibble(col2 = c(1,2,3))  # This fails because col1 is missing try(x(input)) #> Error : missing columns in the `df` parameter of `x(...)`. #> missing: col1 #> consider renaming / creating missing columns before calling `x(...)` #>  # This fixes it for this input x(input, .imap=imapper(col1 = col2))"},{"path":"/reference/in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to confirm that a numeric is in a set range — in_range","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"anticipated part iface rule e.g.","code":""},{"path":"/reference/in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"","code":"in_range(min, max)"},{"path":"/reference/in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"min lower limit (inclusive) max upper limit (inclusive)","code":""},{"path":"/reference/in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"function checks values returns OK throws error ","code":""},{"path":"/reference/in_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"iface(test_col = integer + in_range(-10,10) ~ \"integer -10 10\")","code":""},{"path":"/reference/in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"","code":"in_range(0,100)(1:99) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #> [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #> [76] 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 try(in_range(0,10)(1:99)) #> Error in in_range(0, 10)(1:99) : values not in range: 0-10"},{"path":"/reference/iproto.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a zero length tibble conforming to an iface specification — iproto","title":"Generate a zero length tibble conforming to an iface specification — iproto","text":"function used internally default values dataframe parameter. generates zero length dataframe conforms iface specification, terms column names, data types groupings. dataframe guaranteed fully conformant iface specification , example, completeness constraints applied.","code":""},{"path":"/reference/iproto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a zero length tibble conforming to an iface specification — iproto","text":"","code":"iproto(iface)"},{"path":"/reference/iproto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a zero length tibble conforming to an iface specification — iproto","text":"iface specification","code":""},{"path":"/reference/iproto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a zero length tibble conforming to an iface specification — iproto","text":"tibble conforming iface","code":""},{"path":"/reference/iproto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a zero length tibble conforming to an iface specification — iproto","text":"","code":"i = interfacer::iface(   col1 = integer ~ \"A number\",   col2 = character ~ \"A string\" )  iproto(i) #> # A tibble: 0 × 2 #> # ℹ 2 variables: col1 <int>, col2 <chr>"},{"path":"/reference/ireturn.html","id":null,"dir":"Reference","previous_headings":"","what":"Check a return parameter from a function — ireturn","title":"Check a return parameter from a function — ireturn","text":"intended used within function check validity data frame returned function ispec provided.","code":""},{"path":"/reference/ireturn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check a return parameter from a function — ireturn","text":"","code":"ireturn(df, iface, .prune = FALSE)"},{"path":"/reference/ireturn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check a return parameter from a function — ireturn","text":"df dataframe - missing first parameter calling function assumed dataframe. iface interface specification df conform . .prune get rid excess columns spec.","code":""},{"path":"/reference/ireturn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check a return parameter from a function — ireturn","text":"dataframe based df validity checks passed, datatypes coerced, correct grouping applied conform iface","code":""},{"path":"/reference/ireturn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check a return parameter from a function — ireturn","text":"","code":"input = iface(col_in = integer ~ \"an integer column\" ) output = iface(col_out = integer ~ \"an integer column\" )  x = function(df = input, ...) {   df = ivalidate(...)   tmp = df %>% dplyr::rename(col_out = col_in)   ireturn(tmp, output) } x(tibble::tibble(col_in = c(1,2,3))) #> # A tibble: 3 × 1 #>   col_out #>     <int> #> 1       1 #> 2       2 #> 3       3 output #> A dataframe containing the following columns:  #> * col_out (integer) - an integer column #> No mandatory groupings. #> No default value."},{"path":"/reference/is.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is an interface specification — is.iface","title":"Check if an object is an interface specification — is.iface","text":"Check object interface specification","code":""},{"path":"/reference/is.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is an interface specification — is.iface","text":"","code":"is.iface(x, ...)"},{"path":"/reference/is.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is an interface specification — is.iface","text":"x object check ... ignored","code":""},{"path":"/reference/is.iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is an interface specification — is.iface","text":"boolean.","code":""},{"path":"/reference/is_col_present.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for existence of a set of columns in a dataframe — is_col_present","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"Check existence set columns dataframe","code":""},{"path":"/reference/is_col_present.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"","code":"is_col_present(df, ...)"},{"path":"/reference/is_col_present.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"df dataframe test ... column names (unquoted)","code":""},{"path":"/reference/is_col_present.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"TRUE columns , false otherwise","code":""},{"path":"/reference/is_col_present.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"","code":"is_col_present(iris, Species, Petal.Width) #> [1] TRUE"},{"path":"/reference/itest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test dataframe conformance to an interface specification. — itest","title":"Test dataframe conformance to an interface specification. — itest","text":"ivalidate throws errors deliberately however sometimes dealing invalid input may desirable. itest generally designed used within function specifies expected input using iface, allows function test given input conformant interface.","code":""},{"path":"/reference/itest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test dataframe conformance to an interface specification. — itest","text":"","code":"itest(df = NULL, iface = NULL, .imap = imapper())"},{"path":"/reference/itest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test dataframe conformance to an interface specification. — itest","text":"df dataframe test. missing first parameter calling function assumed dataframe test. iface interface specification produced iface(). missing inferred current function signature. .imap optional mapping specification produced imapper()","code":""},{"path":"/reference/itest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test dataframe conformance to an interface specification. — itest","text":"TRUE dataframe conformant, FALSE otherwise","code":""},{"path":"/reference/itest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test dataframe conformance to an interface specification. — itest","text":"","code":"if (rlang::is_installed(\"ggplot2\")) {   i_diamonds = iface(      color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",      price = integer ~ \"the price\"   )      # Ad hoc testing   itest(ggplot2::diamonds, i_diamonds)      # Use within function:   x = function(df = i_diamonds) {     if(itest()) message(\"PASS!\")   }      x(ggplot2::diamonds) } #> PASS!"},{"path":"/reference/ivalidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"ivalidate(...) intended used within function check validity data frame parameter (usually first parameter) ispec given default value formal parameter.","code":""},{"path":"/reference/ivalidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"","code":"ivalidate(df = NULL, ..., .imap = imapper(), .prune = FALSE, .default = NULL)"},{"path":"/reference/ivalidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"df dataframe - missing first parameter calling function assumed dataframe. ... used ivalidate included call inherit .imap caller function. .imap set mappings imapper object. .prune get rid excess columns spec. .default default dataframe conforming specification. overrides defaults defined interface specification","code":""},{"path":"/reference/ivalidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"dataframe based df validity checks passed .imap mappings applied present","code":""},{"path":"/reference/ivalidate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(...)   return(df) } input=tibble::tibble(col1 = c(1,2,3)) x(input) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3  # This fails because col1 is not coercable to integer input2=tibble::tibble(col1 = c(1.5,2,3)) try(x(input2)) #> Error : input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer: not a true integer input"},{"path":"/reference/knit_print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Format an iface specification for printing — knit_print.iface","title":"Format an iface specification for printing — knit_print.iface","text":"Format iface specification printing","code":""},{"path":"/reference/knit_print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format an iface specification for printing — knit_print.iface","text":"","code":"knit_print.iface(x, ...)"},{"path":"/reference/knit_print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format an iface specification for printing — knit_print.iface","text":"x iface specification ... used.","code":""},{"path":"/reference/knit_print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format an iface specification for printing — knit_print.iface","text":"","code":"my_iface = iface(    col1 = integer + group_unique ~ \"an integer column\" )  print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> No mandatory groupings. #> No default value. knitr::knit_print(my_iface) #> [1] \"A dataframe containing the following columns: \\n\\n* col1 (integer + group_unique) - an integer column\\n\\nNo mandatory groupings.\\n\\nNo default value.\" #> attr(,\"class\") #> [1] \"knit_asis\""},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Format an iface specification for printing — print.iface","title":"Format an iface specification for printing — print.iface","text":"Format iface specification printing","code":""},{"path":"/reference/print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format an iface specification for printing — print.iface","text":"","code":"# S3 method for iface print(x, ...)"},{"path":"/reference/print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format an iface specification for printing — print.iface","text":"x iface specification ... used.","code":""},{"path":"/reference/print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format an iface specification for printing — print.iface","text":"","code":"my_iface = iface(    col1 = integer + group_unique ~ \"an integer column\" )  print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> No mandatory groupings. #> No default value. knitr::knit_print(my_iface) #> [1] \"A dataframe containing the following columns: \\n\\n* col1 (integer + group_unique) - an integer column\\n\\nNo mandatory groupings.\\n\\nNo default value.\" #> attr(,\"class\") #> [1] \"knit_asis\""},{"path":"/reference/roxy_tag_parse.roxy_tag_iparam.html","id":null,"dir":"Reference","previous_headings":"","what":"Parser for @iparam tags — roxy_tag_parse.roxy_tag_iparam","title":"Parser for @iparam tags — roxy_tag_parse.roxy_tag_iparam","text":"@iparam <name> <description> tag can used roxygen documentation function describe dataframe parameter. function must using interfacer::iface define input dataframe parameter format. @iparam tag generate documentation type dataframe function expecting.","code":""},{"path":"/reference/roxy_tag_parse.roxy_tag_iparam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parser for @iparam tags — roxy_tag_parse.roxy_tag_iparam","text":"","code":"# S3 method for roxy_tag_iparam roxy_tag_parse(x)"},{"path":"/reference/roxy_tag_parse.roxy_tag_iparam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parser for @iparam tags — roxy_tag_parse.roxy_tag_iparam","text":"x tag","code":""},{"path":"/reference/roxy_tag_parse.roxy_tag_iparam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parser for @iparam tags — roxy_tag_parse.roxy_tag_iparam","text":"","code":"# This provides support to Roxygen and only gets executed in the context # of `devtools::document()`. There is no interactive use of this function."},{"path":"/reference/roxy_tag_rd.roxy_tag_iparam.html","id":null,"dir":"Reference","previous_headings":"","what":"Support for @iparam tags — roxy_tag_rd.roxy_tag_iparam","title":"Support for @iparam tags — roxy_tag_rd.roxy_tag_iparam","text":"@iparam <name> <description> tag can used roxygen documentation function describe dataframe parameter. function must using interfacer::iface define input dataframe parameter format. @iparam tag generate documentation type dataframe function expecting.","code":""},{"path":"/reference/roxy_tag_rd.roxy_tag_iparam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Support for @iparam tags — roxy_tag_rd.roxy_tag_iparam","text":"","code":"# S3 method for roxy_tag_iparam roxy_tag_rd(x, base_path, env)"},{"path":"/reference/roxy_tag_rd.roxy_tag_iparam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Support for @iparam tags — roxy_tag_rd.roxy_tag_iparam","text":"x tag base_path Path package root directory. env Environment evaluate code (needed)","code":""},{"path":"/reference/roxy_tag_rd.roxy_tag_iparam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Support for @iparam tags — roxy_tag_rd.roxy_tag_iparam","text":"","code":"# An example function definition: fn_definition <- \" #' This is a title #'  #' This is the description. #'  #' @md #' @iparam df the input #' @export f <- function(df = interfacer::iface(   id = integer ~ \\\"an integer `ID`\\\",   test = logical ~ \\\"the test result\\\" )) {   ivalidate(df) } \"  # For this example we manually parse the function specification in `fn_definition` # creating a .Rd block - normally this is done by Roxygen hence the use of  # an internal Roxygen function here. There is no interactive use of this  # function outside of a call to `devtools::document`.  tmp = roxygen2::parse_text(fn_definition) tmp2 = roxygen2:::block_to_rd.roxy_block(tmp[[1]],tempdir(),rlang::current_env()) print(tmp2) #> % Generated by roxygen2: do not edit by hand #> % Please edit documentation in ./<text> #> \\name{f} #> \\alias{f} #> \\title{This is a title} #> \\usage{ #> f( #>   df = interfacer::iface(id = integer ~ \"an integer `ID`\", test = logical ~ #>     \"the test result\") #> ) #> } #> \\arguments{ #> \\item{df}{the input #>  #> A dataframe containing the following columns:  #> \\itemize{ #> \\item id (integer) - an integer `ID` #> \\item test (logical) - the test result #> } #>  #> No mandatory groupings. #>  #> No default value. #> } #> } #> \\description{ #> This is the description. #> }"},{"path":"/reference/switch_pipeline.html","id":null,"dir":"Reference","previous_headings":"","what":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"Branch dplyr pipeline based set conditions","code":""},{"path":"/reference/switch_pipeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"","code":"switch_pipeline(.x, ...)"},{"path":"/reference/switch_pipeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":".x dataframe ... list formulae type predicate ~ purrr function using .x single parameter","code":""},{"path":"/reference/switch_pipeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"result applying purrr function .x case predicate evaluates true. bothe predicate function can refer pipeline dataframe using .x","code":""},{"path":"/reference/switch_pipeline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"","code":"iris %>% switch_pipeline(   is_col_present(.x, Species) ~ .x %>% dplyr::rename(new = Species) ) %>% dplyr::glimpse() #> Rows: 150 #> Columns: 5 #> $ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.… #> $ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.… #> $ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.… #> $ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.… #> $ new          <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…"},{"path":"/reference/type.anything.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to an unspecified type — type.anything","title":"Coerce to an unspecified type — type.anything","text":"Coerce unspecified type","code":""},{"path":"/reference/type.anything.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to an unspecified type — type.anything","text":"","code":"type.anything(x)"},{"path":"/reference/type.anything.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to an unspecified type — type.anything","text":"x vector","code":""},{"path":"/reference/type.anything.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to an unspecified type — type.anything","text":"input (unless x NULL case character())","code":""},{"path":"/reference/type.character.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a character. — type.character","title":"Coerce to a character. — type.character","text":"Coerce character.","code":""},{"path":"/reference/type.character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a character. — type.character","text":"","code":"type.character()"},{"path":"/reference/type.character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a character. — type.character","text":"input character.","code":""},{"path":"/reference/type.complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a complete set of values. — type.complete","title":"Coerce to a complete set of values. — type.complete","text":"test checks either factors factor levels present input, numerics sequence minimum maximum smallest difference (approximately) present. Empty values ignored.","code":""},{"path":"/reference/type.complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a complete set of values. — type.complete","text":"","code":"type.complete(x)"},{"path":"/reference/type.complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a complete set of values. — type.complete","text":"x vector, factor numeric","code":""},{"path":"/reference/type.complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a complete set of values. — type.complete","text":"input error complete","code":""},{"path":"/reference/type.date.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a Date. — type.date","title":"Coerce to a Date. — type.date","text":"Coerce Date.","code":""},{"path":"/reference/type.date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a Date. — type.date","text":"","code":"type.date(x, ...)"},{"path":"/reference/type.date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a Date. — type.date","text":"x object converted. ... arguments passed methods.","code":""},{"path":"/reference/type.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a default value for a column — type.default","title":"Set a default value for a column — type.default","text":"NA values replaced value. N.b. default values must provided rules validation fail.","code":""},{"path":"/reference/type.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a default value for a column — type.default","text":"","code":"type.default(value)"},{"path":"/reference/type.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a default value for a column — type.default","text":"value length one item correct type.","code":""},{"path":"/reference/type.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set a default value for a column — type.default","text":"validation function switches NAs default values","code":""},{"path":"/reference/type.double.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a double. — type.double","title":"Coerce to a double. — type.double","text":"Coerce double.","code":""},{"path":"/reference/type.double.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a double. — type.double","text":"","code":"type.double()"},{"path":"/reference/type.double.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a double. — type.double","text":"input double, error involve data loss.","code":""},{"path":"/reference/type.enum.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to match a factor with specific levels. — type.enum","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"Define conformance rule match factor specific levels.","code":""},{"path":"/reference/type.enum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"","code":"type.enum(..., .drop = FALSE, .ordered = FALSE)"},{"path":"/reference/type.enum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"... levels (quotes, backticks required) .drop levels present data specified cause error (FALSE default) silently dropped NA values (TRUE). .ordered must factor ordered","code":""},{"path":"/reference/type.enum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"function can check convert input factor specified levels. re-level factors matching levels different order.","code":""},{"path":"/reference/type.enum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"","code":"f = type.enum(one,two,three) f(c(\"three\",\"two\",\"one\")) #> [1] three two   one   #> Levels: one two three f(factor(rep(1:3,5), labels = c(\"one\",\"two\",\"three\"))) #>  [1] one   two   three one   two   three one   two   three one   two   three #> [13] one   two   three #> Levels: one two three"},{"path":"/reference/type.factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a factor. — type.factor","title":"Coerce to a factor. — type.factor","text":"Coerce factor.","code":""},{"path":"/reference/type.factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a factor. — type.factor","text":"","code":"type.factor(x)"},{"path":"/reference/type.factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a factor. — type.factor","text":"x vector","code":""},{"path":"/reference/type.factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a factor. — type.factor","text":"input factor, error involve data loss.","code":""},{"path":"/reference/type.finite.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for non-finite values — type.finite","title":"Check for non-finite values — type.finite","text":"non finite values cause failure validation.","code":""},{"path":"/reference/type.finite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for non-finite values — type.finite","text":"","code":"type.finite(x)"},{"path":"/reference/type.finite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for non-finite values — type.finite","text":"x vector can coerced numeric","code":""},{"path":"/reference/type.finite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for non-finite values — type.finite","text":"input coerced numeric value, error non-finite values detected","code":""},{"path":"/reference/type.group_unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a unique value. — type.group_unique","title":"Coerce to a unique value. — type.group_unique","text":"Coerce unique value.","code":""},{"path":"/reference/type.group_unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a unique value. — type.group_unique","text":"","code":"type.group_unique(x)"},{"path":"/reference/type.group_unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a unique value. — type.group_unique","text":"x vector","code":""},{"path":"/reference/type.group_unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a unique value. — type.group_unique","text":"input error x unique.","code":""},{"path":"/reference/type.in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"anticipated part iface rule e.g.","code":""},{"path":"/reference/type.in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"","code":"type.in_range(min, max, include.min = TRUE, include.max = TRUE)"},{"path":"/reference/type.in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"min lower limit max upper limit include.min lower limit open (default TRUE) include.max upper limit open (default TRUE)","code":""},{"path":"/reference/type.in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"function checks values returns OK throws error ","code":""},{"path":"/reference/type.in_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"iface(test_col = integer + in_range(-10,10) ~ \"integer -10 10\")","code":""},{"path":"/reference/type.in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"","code":"type.in_range(0,10,TRUE,TRUE)(0:10) #>  [1]  0  1  2  3  4  5  6  7  8  9 10 try(type.in_range(0,10,TRUE,FALSE)(0:10)) #> Error : values not in range: 0 ≤ x < 10 try(type.in_range(0,10,FALSE)(0:10)) #> Error : values not in range: 0 < x ≤ 10 type.in_range(0,10,FALSE,TRUE)(1:10) #>  [1]  1  2  3  4  5  6  7  8  9 10 type.in_range(0,10,TRUE,FALSE)(0:9) #>  [1] 0 1 2 3 4 5 6 7 8 9 type.in_range(0,Inf,FALSE,FALSE)(1:9) #> [1] 1 2 3 4 5 6 7 8 9 try(type.in_range(0,10)(1:99)) #> Error : values not in range: 0 ≤ x ≤ 10"},{"path":"/reference/type.integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to integer — type.integer","title":"Coerce to integer — type.integer","text":"Coerce integer","code":""},{"path":"/reference/type.integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to integer — type.integer","text":"","code":"type.integer(x)"},{"path":"/reference/type.integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to integer — type.integer","text":"x vector","code":""},{"path":"/reference/type.integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to integer — type.integer","text":"input integer, error involve data loss.","code":""},{"path":"/reference/type.logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a logical — type.logical","title":"Coerce to a logical — type.logical","text":"Coerce logical","code":""},{"path":"/reference/type.logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a logical — type.logical","text":"","code":"type.logical(x)"},{"path":"/reference/type.logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a logical — type.logical","text":"x vector","code":""},{"path":"/reference/type.logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a logical — type.logical","text":"input logical, error involve data loss.","code":""},{"path":"/reference/type.not_missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for missing values — type.not_missing","title":"Check for missing values — type.not_missing","text":"NA values cause failure validation.","code":""},{"path":"/reference/type.not_missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for missing values — type.not_missing","text":"","code":"type.not_missing(x)"},{"path":"/reference/type.not_missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for missing values — type.not_missing","text":"x vector, factor numeric","code":""},{"path":"/reference/type.not_missing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for missing values — type.not_missing","text":"input missing values detected, otherwise error","code":""},{"path":"/reference/type.numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a numeric. — type.numeric","title":"Coerce to a numeric. — type.numeric","text":"Coerce numeric.","code":""},{"path":"/reference/type.numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a numeric. — type.numeric","text":"","code":"type.numeric()"},{"path":"/reference/type.numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a numeric. — type.numeric","text":"input numeric, error involve data loss.","code":""},{"path":"/reference/type.of_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for a given class — type.of_type","title":"Check for a given class — type.of_type","text":"values wrong class cause failure validation. particularly useful custom vectors list types (e.g. list(of_type(lm)))","code":""},{"path":"/reference/type.of_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for a given class — type.of_type","text":"","code":"type.of_type(type, .not_null = FALSE)"},{"path":"/reference/type.of_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for a given class — type.of_type","text":"type class type checking symbol .not_null NULL values allowed (list column entries )","code":""},{"path":"/reference/type.of_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for a given class — type.of_type","text":"function can check input correct type.","code":""},{"path":"/reference/type.positive_double.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a positive double. — type.positive_double","title":"Coerce to a positive double. — type.positive_double","text":"Coerce positive double.","code":""},{"path":"/reference/type.positive_double.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a positive double. — type.positive_double","text":"","code":"type.positive_double(x)"},{"path":"/reference/type.positive_double.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a positive double. — type.positive_double","text":"x object coerced tested.","code":""},{"path":"/reference/type.positive_double.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a positive double. — type.positive_double","text":"input positive double, error involve data loss.","code":""},{"path":"/reference/type.positive_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a positive integer. — type.positive_integer","title":"Coerce to a positive integer. — type.positive_integer","text":"Coerce positive integer.","code":""},{"path":"/reference/type.positive_integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a positive integer. — type.positive_integer","text":"","code":"type.positive_integer(x)"},{"path":"/reference/type.positive_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a positive integer. — type.positive_integer","text":"x vector","code":""},{"path":"/reference/type.positive_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a positive integer. — type.positive_integer","text":"input positive integer, error involve data loss.","code":""},{"path":"/reference/type.proportion.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a number between 0 and 1 — type.proportion","title":"Coerce to a number between 0 and 1 — type.proportion","text":"Coerce number 0 1","code":""},{"path":"/reference/type.proportion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a number between 0 and 1 — type.proportion","text":"","code":"type.proportion(x)"},{"path":"/reference/type.proportion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a number between 0 and 1 — type.proportion","text":"x object coerced tested.","code":""},{"path":"/reference/type.proportion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a number between 0 and 1 — type.proportion","text":"input number 0 1, error involve data loss.","code":""},{"path":"/reference/use_dataframe.html","id":null,"dir":"Reference","previous_headings":"","what":"Use a dataframe in a package including structure based documentation — use_dataframe","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"Using interfacer framework can document data development. provides basic documentation framework dataset based dataframe correct format right place.","code":""},{"path":"/reference/use_dataframe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"","code":"use_dataframe(   df,   name = deparse(substitute(df)),   output = \"R/data.R\",   pkg = \".\" )"},{"path":"/reference/use_dataframe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"df data frame use name name variable wish use (defaults whatever function called ) output write data documentation code (defaults R/data.R) pkg package (defaults current)","code":""},{"path":"/reference/use_dataframe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"nothing, used side effects.","code":""},{"path":"/reference/use_dataframe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"use case interfacer need import interfacer package, none generated code depend .","code":""},{"path":"/reference/use_dataframe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"","code":"# example code if (interactive()) {   # This is not run as it is designed for interactive use only and will   # write to the userspace after checking that is what the user wants.   use_dataframe(iris)  }"},{"path":"/reference/use_iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate interfacer code for a dataframe — use_iface","title":"Generate interfacer code for a dataframe — use_iface","text":"Generating documenting iface given dataframe time consuming annoying automatically. case interactively develop package using test dataframe, structure can explicitly documented made specific contract within package. supports development using test dataframes prototype function ensuring future user input conforms expectations test data.","code":""},{"path":"/reference/use_iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate interfacer code for a dataframe — use_iface","text":"","code":"use_iface(   df,   name = deparse(substitute(df)),   output = \"R/interfaces.R\",   use_as_default = FALSE,   pkg = \".\" )"},{"path":"/reference/use_iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate interfacer code for a dataframe — use_iface","text":"df data frame use name name variable wish use (defaults whatever dataframe called) output within current package write data documentation code (defaults R/interfaces.R) use_as_default set true current dataframe saved package data interfacer::iface specification created referring package copy current dataframe default value. pkg package (defaults current)","code":""},{"path":"/reference/use_iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate interfacer code for a dataframe — use_iface","text":"nothing, used side effects.","code":""},{"path":"/reference/use_iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate interfacer code for a dataframe — use_iface","text":"","code":"# example code if (interactive()) {   # This is not run as it is designed for interactive use only and will   # write to the userspace after checking that is what the user wants.   use_iface(iris)  }"},{"path":"/news/index.html","id":"interfacer-021","dir":"Changelog","previous_headings":"","what":"interfacer 0.2.1","title":"interfacer 0.2.1","text":"Added NEWS.md file track changes package. Initial CRAN submission.","code":""}]
