[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 interfacer authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rob Challen. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2023). interfacer: Define Enforce Interface Contracts Dataframes. R package version 0.0.1.","code":"@Manual{,   title = {interfacer: Define and Enforce Interface Contracts for Dataframes},   author = {Rob Challen},   year = {2023},   note = {R package version 0.0.1}, }"},{"path":"/index.html","id":"interfacer","dir":"","previous_headings":"","what":"Define and Enforce Interface Contracts for Dataframes","title":"Define and Enforce Interface Contracts for Dataframes","text":"Specify enforce contracts R dataframes","code":""},{"path":"/reference/format.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Encode in a Common Format — format.iface","title":"Encode in a Common Format — format.iface","text":"Format R object pretty printing.","code":""},{"path":"/reference/format.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Encode in a Common Format — format.iface","text":"","code":"# S3 method for iface format(x, ...)"},{"path":"/reference/format.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Encode in a Common Format — format.iface","text":"x R object (conceptually); typically numeric. ... arguments passed methods.","code":""},{"path":"/reference/format.iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Encode in a Common Format — format.iface","text":"object similar structure x containing character   representations elements first argument x common format, current locale's encoding. character, numeric, complex factor x, dims dimnames   preserved matrices/arrays names vectors:   attributes copied. x list, result character vector obtained   applying format.default(x, ...) element list   (unlisting elements lists),   collapsing result element  paste(collapse = \", \").  defaults case  trim = TRUE, justify = \"none\" since one usually want   alignment collapsed strings.","code":""},{"path":"/reference/format.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Encode in a Common Format — format.iface","text":"format generic function.  Apart methods described   methods dates (see format.Date),   date-times (see format.POSIXct) classes   format.octmode format.dist. format.data.frame formats data frame column column,   applying appropriate method format column.   Methods columns often similar .character offer   control.  Matrix data-frame columns converted   separate columns result, character columns (normally )   given class \"AsIs\". format.factor converts factor character vector   calls default method (justify applies). format.AsIs deals columns complicated objects   extracted data frame.  Character objects (atomic)   matrices passed default method (width   apply).   Otherwise calls toString convert object   character (vector list, element element)   right-justifies result. Justification character vectors (objects converted   character vectors methods) done display width (see   nchar), taking double-width characters rendering   special characters (escape sequences, including escaping   backslash double quote: see print.default)   account.  Thus width displayed print(quote =   FALSE) displayed cat.  Character strings   padded blanks display width widest.  (  na.encode = FALSE missing character strings included   width computations encoded.) Numeric vectors encoded minimum number decimal places   needed display elements least digits   significant digits.  However, elements trailing   zeroes, number decimal places reduced least one   element non-zero final digit; see also argument   documentation big.*, small.* etc, .  See   note print.default digits >= 16. Raw vectors converted 2-digit hexadecimal representation   .character. format.default(x) now provides “minimal” string   isS4(x) true. internal code respects option   getOption(\"OutDec\") ‘decimal mark’,   set something \".\" takes precedence   argument decimal.mark.","code":""},{"path":"/reference/format.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Encode in a Common Format — format.iface","text":"Becker, R. ., Chambers, J. M. Wilks, . R. (1988)   New S Language.   Wadsworth & Brooks/Cole.","code":""},{"path":[]},{"path":"/reference/format.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Encode in a Common Format — format.iface","text":"","code":"format(1:10) #>  [1] \" 1\" \" 2\" \" 3\" \" 4\" \" 5\" \" 6\" \" 7\" \" 8\" \" 9\" \"10\" format(1:10, trim = TRUE) #>  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"  zz <- data.frame(\"(row names)\"= c(\"aaaaa\", \"b\"), check.names = FALSE) format(zz) #>   (row names) #> 1       aaaaa #> 2           b format(zz, justify = \"left\") #>   (row names) #> 1       aaaaa #> 2       b      ## use of nsmall format(13.7) #> [1] \"13.7\" format(13.7, nsmall = 3) #> [1] \"13.700\" format(c(6.0, 13.1), digits = 2) #> [1] \" 6\" \"13\" format(c(6.0, 13.1), digits = 2, nsmall = 1) #> [1] \" 6.0\" \"13.1\"  ## use of scientific format(2^31-1) #> [1] \"2147483647\" format(2^31-1, scientific = TRUE) #> [1] \"2.147484e+09\"  ## a list z <- list(a = letters[1:3], b = (-pi+0i)^((-2:2)/2), c = c(1,10,100,1000),           d = c(\"a\", \"longer\", \"character\", \"string\"),           q = quote( a + b ), e = expression(1+x)) ## can you find the \"2\" small differences? (f1 <- format(z, digits = 2)) #>                                                              a  #>                                                      \"a, b, c\"  #>                                                              b  #> \"-0.32+0.00i, 0.00-0.56i, 1.00+0.00i, 0.00+1.77i, -3.14+0.00i\"  #>                                                              c  #>                                             \"1, 10, 100, 1000\"  #>                                                              d  #>                   \"a        , longer   , character, string   \"  #>                                                              q  #>                                                        \"a + b\"  #>                                                              e  #>                                            \"expression(1 + x)\"  (f2 <- format(z, digits = 2, justify = \"left\", trim = FALSE)) #>                                                                 a  #>                                                         \"a, b, c\"  #>                                                                 b  #> \"-0.32+0.00i,  0.00-0.56i,  1.00+0.00i,  0.00+1.77i, -3.14+0.00i\"  #>                                                                 c  #>                                          \"   1,   10,  100, 1000\"  #>                                                                 d  #>                      \"a        , longer   , character, string   \"  #>                                                                 q  #>                                                           \"a + b\"  #>                                                                 e  #>                                               \"expression(1 + x)\"  f1 == f2 ## 2 FALSE, 4 TRUE #>     a     b     c     d     q     e  #>  TRUE FALSE FALSE  TRUE  TRUE  TRUE   ## A \"minimal\" format() for S4 objects without their own format() method: cc <- methods::getClassDef(\"standardGeneric\") format(cc) ## \"<S4 class ......>\" #> [1] \"<S4 class ‘classRepresentation’ [package “methods”] with 11 slots>\""},{"path":"/reference/idocument.html","id":null,"dir":"Reference","previous_headings":"","what":"Document an interface contract for inserting in to Roxygen — idocument","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"function expected called within documentation function inline code parameter documentation function. details expected columns input dataframe possess.","code":""},{"path":"/reference/idocument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"","code":"idocument(fn, param)"},{"path":"/reference/idocument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"fn function documenting param parameter documenting","code":""},{"path":"/reference/idocument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"markdown snippet","code":""},{"path":"/reference/idocument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Document an interface contract for inserting in to Roxygen — idocument","text":"","code":"#' @param df `r idocument(x, df)` x = function(df = iface( col1 = integer ~ \"an integer column\" )) {}  cat(idocument(x, df)) #> A dataframe containing the following columns:  #> * col1 (integer} - an integer column"},{"path":"/reference/iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Define an interface — iface","title":"Define an interface — iface","text":"default value dataframe. specificiation form named list formulae structure name = type ~ \"documentation\"","code":""},{"path":"/reference/iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an interface — iface","text":"","code":"iface(...)"},{"path":"/reference/iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an interface — iface","text":"... specification interface (see details)","code":""},{"path":"/reference/iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define an interface — iface","text":"definition interface iface object","code":""},{"path":"/reference/iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define an interface — iface","text":"","code":"my_iface = iface(col1 = integer ~ \"an integer column\" ) print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer} - an integer column  x = function(df = my_iface, ...) {   df = ivalidate(df,...)   return(df) }  x(tibble::tibble(col1 = c(1,2,3))) #> Error in eval(icall): object 'my_iface' not found  my_iface2 = iface(my_iface, col2 = character ~ \"another col\") print(my_iface2) #> A dataframe containing the following columns:  #> * col1 (integer} - an integer column #> * col2 (character} - another col"},{"path":"/reference/imap.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify mappings that can make dataframes compatible with an interface — imap","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"function expected used .imap = imap(...) context overcome mapping issues","code":""},{"path":"/reference/imap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"imap(...)"},{"path":"/reference/imap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"... set dplyr::mutate() specifications applied dataframe rename otherwise fix missing columns","code":""},{"path":"/reference/imap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"set mappings","code":""},{"path":"/reference/imap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...) } input=tibble::tibble(col2 = c(1,2,3))  # This fails because col1 is missing try(x(input)) #> Error in ivalidate(df, ...) :  #>   1 missing columns in parameter `df` in call to x(...) #> consider renaming to create `col1` columns #> or by adding `.imap = interfacer::imap(`col1` = ???)` to your function call. #>  # This fixes it for this input x(input, .imap=imap(col1 = col2))"},{"path":"/reference/ivalidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"Perform interface checks dataframe looking enclosing function","code":""},{"path":"/reference/ivalidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"","code":"ivalidate(df, ..., .imap = imap(), prune = FALSE)"},{"path":"/reference/ivalidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"df dataframe ... used .imap set mappings imap object prune get rid excess columns spec","code":""},{"path":"/reference/ivalidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"dataframe based df ","code":""},{"path":"/reference/ivalidate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform interface checks on dataframe by looking at enclosing function — ivalidate","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...)   return(df) } input=tibble::tibble(col1 = c(1,2,3))  x(input) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3  # This fails because col1 is not coercable to integer input2=tibble::tibble(col1 = c(1.5,2,3))  try(x(input2)) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Values — print.iface","title":"Print Values — print.iface","text":"print prints argument returns invisibly (via   invisible(x)).  generic function means   new printing methods can easily added new classes.","code":""},{"path":"/reference/print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Values — print.iface","text":"","code":"# S3 method for iface print(x, ...)"},{"path":"/reference/print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Values — print.iface","text":"x object used select method. ... arguments passed methods.","code":""},{"path":"/reference/print.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print Values — print.iface","text":"default method, print.default help page.   Use methods(\"print\") get methods   print generic. print.factor allows customization used printing   ordered factors well. print.table printing tables allows   customization.  R 3.0.0, prints description case table   0-extents (can happen classifier valid data). See noquote example class whose main   purpose specific print method.","code":""},{"path":"/reference/print.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Print Values — print.iface","text":"Chambers, J. M. Hastie, T. J. (1992)   Statistical Models S.   Wadsworth & Brooks/Cole.","code":""},{"path":[]},{"path":"/reference/print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Values — print.iface","text":"","code":"require(stats)  ts(1:20)  #-- print is the \"Default function\" --> print.ts(.) is called #> Time Series: #> Start = 1  #> End = 20  #> Frequency = 1  #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 for(i in 1:3) print(1:i) #> [1] 1 #> [1] 1 2 #> [1] 1 2 3  ## Printing of factors attenu$station ## 117 levels -> 'max.levels' depending on width #>   [1] 117  1083 1095 283  135  475  113  1008 1028 2001 117  1117 1438 1083 1013 #>  [16] 1014 1015 1016 1095 1011 1028 270  280  116  266  117  113  112  130  475  #>  [31] 269  135  1093 1093 111  116  290  112  113  128  126  127  141  266  110  #>  [46] 1027 111  125  135  475  262  269  1052 411  290  130  272  1096 1102 112  #>  [61] 113  1028 2714 2708 2715 3501 655  272  1032 1377 1028 1250 1051 1293 1291 #>  [76] 1292 283  885  <NA> 2734 <NA> 2728 1413 1445 1408 1411 1410 1409 1377 1492 #>  [91] 1251 1422 1376 <NA> 286  <NA> 5028 942  <NA> 5054 958  952  5165 117  955  #> [106] 5055 <NA> <NA> 5060 412  5053 5058 5057 <NA> 5051 <NA> 5115 <NA> 931  5056 #> [121] 5059 5061 <NA> 5062 5052 <NA> 724  <NA> 5066 5050 2316 5055 942  5028 5165 #> [136] 952  958  955  117  412  5053 5054 5058 5057 5115 5056 5060 1030 1418 1383 #> [151] 1308 1298 1299 1219 <NA> <NA> 1030 1418 1383 <NA> 1299 1308 1219 1456 5045 #> [166] 5044 5160 5043 5047 c168 5068 c118 5042 5067 5049 c204 5070 c266 c203 5069 #> [181] 5073 5072 #> 117 Levels: 1008 1011 1013 1014 1015 1016 1027 1028 1030 1032 1051 1052 ... c266  ## ordered factors: levels  \"l1 < l2 < ..\" esoph$agegp[1:12] #>  [1] 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 #> Levels: 25-34 < 35-44 < 45-54 < 55-64 < 65-74 < 75+ esoph$alcgp[1:12] #>  [1] 0-39g/day 0-39g/day 0-39g/day 0-39g/day 40-79     40-79     40-79     #>  [8] 40-79     80-119    80-119    80-119    120+      #> Levels: 0-39g/day < 40-79 < 80-119 < 120+  ## Printing of sparse (contingency) tables set.seed(521) t1 <- round(abs(rt(200, df = 1.8))) t2 <- round(abs(rt(200, df = 1.4))) table(t1, t2) # simple #>     t2 #> t1    0  1  2  3  4  5  6  7  8 10 17 21 30 #>   0  21 22 14  4  1  0  1  1  1  0  1  0  0 #>   1  25 21  7  3  4  2  1  1  1  1  0  0  0 #>   2   8 16  9  2  0  0  0  0  0  0  0  1  1 #>   3   3  7  0  2  0  0  0  0  0  0  0  0  0 #>   4   1  5  2  0  0  0  1  0  0  0  0  0  0 #>   5   1  1  1  0  0  0  0  0  0  0  0  0  0 #>   6   1  3  0  0  0  0  0  0  0  0  0  0  0 #>   7   1  0  0  0  0  0  0  0  0  0  0  0  0 #>   9   0  0  0  1  0  0  0  0  0  0  0  0  0 #>   12  1  0  0  0  0  0  0  0  0  0  0  0  0 print(table(t1, t2), zero.print = \".\") # nicer to read #>     t2 #> t1    0  1  2  3  4  5  6  7  8 10 17 21 30 #>   0  21 22 14  4  1  .  1  1  1  .  1  .  . #>   1  25 21  7  3  4  2  1  1  1  1  .  .  . #>   2   8 16  9  2  .  .  .  .  .  .  .  1  1 #>   3   3  7  .  2  .  .  .  .  .  .  .  .  . #>   4   1  5  2  .  .  .  1  .  .  .  .  .  . #>   5   1  1  1  .  .  .  .  .  .  .  .  .  . #>   6   1  3  .  .  .  .  .  .  .  .  .  .  . #>   7   1  .  .  .  .  .  .  .  .  .  .  .  . #>   9   .  .  .  1  .  .  .  .  .  .  .  .  . #>   12  1  .  .  .  .  .  .  .  .  .  .  .  .  ## same for non-integer \"table\": T <- table(t2,t1) T <- T * (1+round(rlnorm(length(T)))/4) print(T, zero.print = \".\") # quite nicer, #>     t1 #> t2       0     1     2     3     4     5     6     7     9    12 #>   0  26.25 25.00 10.00  3.75  1.50  1.25  1.25  1.00     .  2.00 #>   1  22.00 26.25 16.00 10.50 27.50  1.25  3.00     .     .     . #>   2  21.00  7.00 13.50     .  3.00  1.25     .     .     .     . #>   3   5.00  3.75  2.50  2.50     .     .     .     .  1.50     . #>   4   1.25  5.00     .     .     .     .     .     .     .     . #>   5      .  2.00     .     .     .     .     .     .     .     . #>   6   1.25  1.50     .     .  1.25     .     .     .     .     . #>   7   1.25  1.25     .     .     .     .     .     .     .     . #>   8   1.50  1.00     .     .     .     .     .     .     .     . #>   10     .  1.00     .     .     .     .     .     .     .     . #>   17  1.00     .     .     .     .     .     .     .     .     . #>   21     .     .  2.75     .     .     .     .     .     .     . #>   30     .     .  5.00     .     .     .     .     .     .     . print.table(T[,2:8] * 1e9, digits=3, zero.print = \".\") #>     t1 #> t2          1        2        3        4        5        6        7 #>   0  2.50e+10 1.00e+10 3.75e+09 1.50e+09 1.25e+09 1.25e+09 1.00e+09 #>   1  2.62e+10 1.60e+10 1.05e+10 2.75e+10 1.25e+09 3.00e+09        . #>   2  7.00e+09 1.35e+10        . 3.00e+09 1.25e+09        .        . #>   3  3.75e+09 2.50e+09 2.50e+09        .        .        .        . #>   4  5.00e+09        .        .        .        .        .        . #>   5  2.00e+09        .        .        .        .        .        . #>   6  1.50e+09        .        . 1.25e+09        .        .        . #>   7  1.25e+09        .        .        .        .        .        . #>   8  1.00e+09        .        .        .        .        .        . #>   10 1.00e+09        .        .        .        .        .        . #>   17        .        .        .        .        .        .        . #>   21        . 2.75e+09        .        .        .        .        . #>   30        . 5.00e+09        .        .        .        .        . ## still slightly inferior to  Matrix::Matrix(T)  for larger T  ## Corner cases with empty extents: table(1, NA) # < table of extent 1 x 0 > #> < table of extent 1 x 0 >"}]
