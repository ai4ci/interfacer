[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 interfacer authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/interfacer.html","id":"defining-an-interface","dir":"Articles","previous_headings":"","what":"Defining an interface","title":"interfacer","text":"interface defines structure acceptable dataframes. list column names, plus types documentation column. Printing interface specification shows structure iface defines. interface specification enforced default value function. dummy default value combined ivalidate function body passed parameter can validated ensure dataframe right shape. can use idocument Roxygen skeleton document dataframe constraints. case later call example_fn data checked requirements ivalidate, acceptable passed rest function body (case result returned). pass non-conformant data ivalidate throws informative error wrond data. case test column missing: can recover error renaming columns passing bad_example_data example_fn(). Alternatively can use dynamic dots pass mapping ivalidate applied validation. parameter called .imap, contents imapper() holds set expressions used dplyr::mutate call).","code":"i_test = iface(   id = integer ~ \"an integer ID\",   test = logical ~ \"the test result\" ) cat(print(i_test)) #> A dataframe containing the following columns:  #> * id (integer) - an integer ID #> * test (logical) - the test result #> No mandatory groupings. #> No default value. #' An example function #' #' @param mydata `r idocument(example_fn, mydata)` #' @param another an example    #' @param ... not used #' #' @return the conformant dataframe #' @export example_fn = function(   mydata = i_test,   another = \"value\",   ... ) {   mydata = ivalidate(mydata, ...)   return(mydata) } example_data = tibble::tibble(     id=c(1,2,3),     test = c(TRUE,FALSE,TRUE)   )  # this returns the qualifying data example_fn(   example_data,    \"value for another\" ) %>% dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ id   <int> 1, 2, 3 #> $ test <lgl> TRUE, FALSE, TRUE bad_example_data = tibble::tibble(     id=c(1,2,3),     wrong_name = c(TRUE,FALSE,TRUE)   )  # this causes an error as example_data_2$wrong_test is wrongly named try(example_fn(   bad_example_data,    \"value for another\" )) #> Error : missing columns in the `mydata` parameter of example_fn(..). #> missing: test #> consider renaming / creating missing columns before calling `example_fn`(...) #> or by adding `.imap = interfacer::imapper(`test`=...)` to your function call. example_fn(   bad_example_data,    \"value for another\",   .imap = interfacer::imapper(test = wrong_name) ) %>% dplyr::glimpse() #> Rows: 3 #> Columns: 3 #> $ id         <int> 1, 2, 3 #> $ wrong_name <lgl> TRUE, FALSE, TRUE #> $ test       <lgl> TRUE, FALSE, TRUE"},{"path":"/articles/interfacer.html","id":"extension-and-composition","dir":"Articles","previous_headings":"","what":"Extension and composition","title":"interfacer","text":"useful interface specifications can composed extended. case subtype iface specification can created: extended iface used constrain input another function specifying default value. can also constrain output function conformant another specification usng ireturn. Examples documenting input parameter output parameter provided : case ivalidate call prunes unneeded data dataframe, removing extra columns, also ensures input grouped way. Grouping rejected grouping incorrect. inforative error message provided: Following instructions error message makes previously failing data validate i_test_extn:","code":"i_test_extn = iface(   i_test,   extra = character ~ \"a new value\",   .groups = FALSE )  print(i_test_extn) #> A dataframe containing the following columns:  #> * id (integer) - an integer ID #> * test (logical) - the test result #> * extra (character) - a new value #> Ungrouped. #> No default value. #' Another example function  #'  #' @param mydata `r idocument(example_fn2, mydata)` #' @param another an example    #' @param ... not used #' #' @return `r i_test` #' @export example_fn2 = function(     mydata = i_test_extn,     ... ) {   mydata = ivalidate(mydata, ..., .prune = TRUE)   mydata = mydata %>% dplyr::select(-extra)   # check the return value conforms to a new specification   ireturn(mydata, i_test) } grouped_example_data = tibble::tibble(     id = c(1,2,3),     test = c(TRUE,FALSE,TRUE),     extra = c(\"a\",\"b\",\"c\"),     unneeded = c(\"x\",\"y\",\"z\")   ) %>% dplyr::group_by(id) try(example_fn2(grouped_example_data)) #> Error : unexpected additional groups in `mydata` parameter of example_fn2(...) #> additional: id #> consider regrouping your data before calling function `example_fn2`, e.g.: #> `df %>% ungroup() %>% example_fn2(...)` #> or calling function `example_fn2` using a group_modify, e.g.: #> `df %>% group_by(id) %>% group_modify(example_fn2, ...)` grouped_example_data %>%    dplyr::ungroup() %>%    example_fn2() %>%    dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ id   <int> 1, 2, 3 #> $ test <lgl> TRUE, FALSE, TRUE"},{"path":"/articles/interfacer.html","id":"documentation","dir":"Articles","previous_headings":"","what":"Documentation","title":"interfacer","text":"roxygen block documentation second interface determined #' @param block function idocument takes function name optionally parameter name writes informative block dataframe expected function:","code":"cat(idocument(example_fn2)) #> A dataframe containing the following columns:  #> - id (integer) - an integer ID #> - test (logical) - the test result #> - extra (character) - a new value #>  #> Ungrouped. #>  #> No default value."},{"path":"/articles/interfacer.html","id":"type-coercion","dir":"Articles","previous_headings":"","what":"Type coercion","title":"interfacer","text":"interfacer implement rigid type system, rather permissve one. provided data can coerced specified type without major loss automatically done, long can proceed warnings. example id (int) provided character extra (character) coerced provided numeric. Completely incorrect data types hans picked rejected. case data supplied id cast integer without loss. Similar behaviour seen logical data anything 0 1 example. Factors might allowable levels well. define enum accepts list values, must matched levels provided factor. order levels taken iface spec relveleving inputs taken ensure factor levels match spec. .drop = TRUE specified values don’t match levels cast NA rather causing failure allow conformance subset factor values.","code":"example_fn2(   tibble::tibble(     id=c(\"1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE),     extra = 1.1   )) %>% dplyr::glimpse() #> Rows: 3 #> Columns: 2 #> $ id   <int> 1, 2, 3 #> $ test <lgl> TRUE, FALSE, TRUE try(example_fn(   tibble::tibble(     id= c(\"1.1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE)   ))) #> Error in dplyr::mutate(., `:=`(!!data_col, asfn2(!!data_col))) :  #>   ℹ In argument: `id = asfn2(id)`. #> Caused by error: #> ! input column `id` in function parameter `example_fn(mydata = ?)` cannot be coerced to a integer: not a true integer input if (rlang::is_installed(\"ggplot2\")) {      i_diamonds = iface(      color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",     cut = enum(Ideal, Premium, .drop=TRUE) ~ \"the cut\",     price = integer ~ \"the price\"   )      # itest(ggplot2::diamonds, i_diamonds)   iconvert(ggplot2::diamonds, i_diamonds, .prune = TRUE)     } %>% dplyr::glimpse() #> Rows: 53,940 #> Columns: 3 #> $ color <fct> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I, E… #> $ cut   <fct> Ideal, Premium, NA, Premium, NA, NA, NA, NA, NA, NA, NA, Ideal, … #> $ price <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 342,…"},{"path":"/articles/interfacer.html","id":"grouping","dir":"Articles","previous_headings":"","what":"Grouping","title":"interfacer","text":"iface spec can permissive dogmatic grouping input. .groups option iface spec NULL (e.g. iface(..., .groups=NULL)) grouping allowed. FALSE grouping allowd. third option supply one sided formula. case variables formula define grouping must present, e.g. ~ grp1 + grp2, also includes ., additional grouping also permitted (e.g.  ~ . + grp1 + grp2) allows grouping df %>% group_by(anything, grp1, grp2). N.B. ordering grouping mostly expected work progress, makes sense mandatory groups right / granular groups. group column specified must present, regardless rest iface spec. example cut required i_diamonds contract can format.","code":"i_diamonds = interfacer::iface(     carat = numeric ~ \"the carat column\",     color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",     x = numeric ~ \"the x column\",     y = numeric ~ \"the y column\",     z = numeric ~ \"the z column\",     .groups = ~ . + carat + cut )  # permissive grouping with the `~ . + carat + cut` groups rule ggplot2::diamonds %>%    dplyr::group_by(color, carat, cut) %>%    iconvert(i_diamonds, .prune = TRUE) %>%    dplyr::glimpse() #> Rows: 53,940 #> Columns: 6 #> Groups: color, carat, cut [4,803] #> $ color <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I, E… #> $ carat <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.30… #> $ cut   <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Very … #> $ x     <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.25… #> $ y     <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.28… #> $ z     <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.73…"},{"path":"/articles/interfacer.html","id":"dispatch","dir":"Articles","previous_headings":"","what":"Dispatch","title":"interfacer","text":"Dispatching one number functions based nature dataframe input enabled idispatch(...). emulates behaviour S3 classes dataframes, based columns also grouping. example following: call disp_example() data matches i_test_extn specification get one type behaviour: call disp_example() data matches i_test specification get different behaviour:","code":"disp_example = function(x, ...) {   idispatch(x,     disp_example.extn = i_test_extn,     disp_example.no_extn = i_test   ) }  disp_example.extn = function(x = i_test_extn, ...) {   # idispatch has already validated x so we don't need to do it again here   message(\"extended data\")   return(colnames(x)) }  disp_example.no_extn = function(x = i_test, ...) {   # in this toy example the function content is very similar.   message(\"not extended data\")   return(colnames(x)) } tmp = tibble::tibble(     id=c(\"1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE),     extra = 1.1 )  tmp %>% disp_example() #> extended data #> [1] \"id\"    \"test\"  \"extra\" # this matches the i_test_extn specifciation: tmp2 = tibble::tibble(     id=c(\"1\",\"2\",\"3\"),     test = c(TRUE,FALSE,TRUE) )  tmp2 %>% disp_example() #> not extended data #> [1] \"id\"   \"test\""},{"path":"/articles/interfacer.html","id":"recursive-dispatch","dir":"Articles","previous_headings":"Dispatch","what":"Recursive dispatch","title":"interfacer","text":"order rules important general detailed needing de provided first. can leverage create recursive functional pattern dataframe processing allows multiple inputs converge single output, also demonstrates use itest() simply checks input conforms iface spec: Processing input type 1 results one path data pipeline: Processing input type 2, results different path data pipeline, outcome: Care must taken though pattern, particularly re-using column names,datatype coercion result column types switched backwards forwards, infinite loop problems.","code":"i_input_1 = iface(   x = integer ~ \"the positives\",   n = default(100) + integer ~ \"the total\" )  i_input_2 = iface(   p = proportion ~ \"the proportion\",   n = default(100) + integer ~ \"the total\" )  i_interim = iface(   i_input_1,   i_input_2 )  i_final = iface(   i_interim,   lower = double ~ \"wilson lower CI\",   upper = double ~ \"wilson lower CI\",   mean = double ~ \"wilson mean\" )  i_target = iface(   i_final,   label = character ~ \"a printable label\" )  process.input_1 = function(x = i_input_1,...) {   return(x %>% dplyr::mutate(p = x/n)) }  process.input_2 = function(x = i_input_1,...) {   return(x %>% dplyr::mutate(x = floor(p*n))) }  process.interim = function(x) {   return(x %>% dplyr::mutate(binom::binom.wilson(x,n))) }  process.final = function(x) {   return(x %>% dplyr::mutate(label = sprintf(\"%1.1f%% [%1.1f%% - %1.1f%%] (%d/%d)\",      mean*100, lower*100, upper*100, x, n))) }  process = function(x,...) {   # this test must be at the front to prevent infinite recursion   if (itest(x, i_target)) return(x)   out = idispatch(x,     process.final = i_final,     process.interim = i_interim,     process.input_2 = i_input_2,     process.input_1 = i_input_1   )   return(process(out)) } # tibble::tibble(x=c(10,30), n=c(NA,50)) %>% itest(i_input_1) process(tibble::tibble(x=c(10,30), n=c(NA,50))) %>% dplyr::glimpse() #> Rows: 2 #> Columns: 8 #> $ x      <int> 10, 30 #> $ n      <int> 100, 50 #> $ p      <dbl> 0.1, 0.6 #> $ method <chr> \"wilson\", \"wilson\" #> $ mean   <dbl> 0.1, 0.6 #> $ lower  <dbl> 0.05522914, 0.46181438 #> $ upper  <dbl> 0.1743657, 0.7239161 #> $ label  <chr> \"10.0% [5.5% - 17.4%] (10/100)\", \"60.0% [46.2% - 72.4%] (30/50)\" # tibble::tibble(p=0.15,n=1000) %>% itest(i_input_2) process(tibble::tibble(p=0.15,n=1000)) %>% dplyr::glimpse() #> Rows: 1 #> Columns: 8 #> $ p      <dbl> 0.15 #> $ n      <int> 1000 #> $ x      <int> 150 #> $ method <chr> \"wilson\" #> $ mean   <dbl> 0.15 #> $ lower  <dbl> 0.1292101 #> $ upper  <dbl> 0.1734687 #> $ label  <chr> \"15.0% [12.9% - 17.3%] (150/1000)\""},{"path":"/articles/interfacer.html","id":"grouping-based-dispatch","dir":"Articles","previous_headings":"Dispatch","what":"Grouping based dispatch","title":"interfacer","text":"often useful function can expects specific grouping can handle additional groups. One way handling use purrr nest columns extensively. Nesting data unexpected groups repeatedly applying function want. alternative dplyr solution use group_modify. interfacer leverages second option automatically determine grouping necessary pipeline function stated grouping requirements automatically handle without additional coding package. example following iface input function must grouped color column: package developer writing pipeline function may use fact handle possible additional grouping using igroup_process(df, ...) pass correctly grouped data conforming i_diamond_price inner function executed transparently, input validated: hand additional groups present inner function executed additional groups. Data validation happens per group. output actually grouped cut clarity color column consumed nested function igroup_process.","code":"i_diamond_price = interfacer::iface(   color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",   price = integer ~ \"the price column\",   .groups = ~ color ) # exported function in package  # at param can use `r idocument(ex_mean, df)` for documentation  ex_mean = function(df = i_diamond_price, extra_param = \".\") {     # dispatch based on groupings:    igroup_process(df,       # the real work of this function is provided as an anonymous inner      # function (but can be any other function e.g. package private function)      # or a purrr style lambda.       function(df, extra_param) {        message(extra_param, appendLF = FALSE)        return(df %>% dplyr::summarise(mean_price = mean(price)))      }     )  } # The correctly grouped dataframe ggplot2::diamonds %>%   dplyr::group_by(color) %>%   ex_mean(extra_param = \"without additional groups...\") %>%   dplyr::glimpse() #> without additional groups... #> Rows: 7 #> Columns: 2 #> $ color      <ord> D, E, F, G, H, I, J #> $ mean_price <dbl> 3169.954, 3076.752, 3724.886, 3999.136, 4486.669, 5091.875,… # The incorrectly grouped dataframe ggplot2::diamonds %>%   dplyr::group_by(cut, color, clarity) %>%   ex_mean() %>%   dplyr::glimpse() #> ........................................ #> Rows: 276 #> Columns: 4 #> Groups: cut, clarity [40] #> $ cut        <ord> Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair,… #> $ clarity    <ord> I1, I1, I1, I1, I1, I1, I1, SI2, SI2, SI2, SI2, SI2, SI2, S… #> $ color      <ord> D, E, F, G, H, I, J, D, E, F, G, H, I, J, D, E, F, G, H, I,… #> $ mean_price <dbl> 7383.000, 2095.222, 2543.514, 3187.472, 4212.962, 3501.000,…"},{"path":"/articles/interfacer.html","id":"complex-rules-composition","dir":"Articles","previous_headings":"","what":"Complex rules & composition","title":"interfacer","text":"section used pseudo-function default(100) + integer specify input column x. also talked use enum(...) rule match factors. range possible modifiers possible group_unique complete enforce uniqueness completeness factors natural numeric sequences.","code":""},{"path":"/articles/interfacer.html","id":"default-values","dir":"Articles","previous_headings":"","what":"Default values","title":"interfacer","text":"","code":"i_iris = interfacer::iface(     Sepal.Length = numeric ~ \"the Sepal.Length column\",     Sepal.Width = numeric ~ \"the Sepal.Width column\",     Petal.Length = numeric ~ \"the Petal.Length column\",     Petal.Width = numeric ~ \"the Petal.Width column\",     Species = enum(`setosa`,`versicolor`,`virginica`) ~ \"the Species column\",     .groups = NULL,   .default = TRUE )  test_fn = function(i = i_iris, ...) {   i = ivalidate(i,...)   return(i) }  # Outputs a zero length data frame test_fn() %>% dplyr::glimpse() #> Rows: 0 #> Columns: 5 #> $ Sepal.Length <dbl>  #> $ Sepal.Width  <dbl>  #> $ Petal.Length <dbl>  #> $ Petal.Width  <dbl>  #> $ Species      <fct>"},{"path":"/articles/interfacer.html","id":"nesting-list-columns","dir":"Articles","previous_headings":"","what":"Nesting & list columns","title":"interfacer","text":"","code":"i_diamonds_cat = interfacer::iface(   cut = enum(`Fair`,`Good`,`Very Good`,`Premium`,`Ideal`, .ordered=TRUE) ~ \"the cut column\",   color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",   clarity = enum(`I1`,`SI2`,`SI1`,`VS2`,`VS1`,`VVS2`,`VVS1`,`IF`, .ordered=TRUE) ~ \"the clarity column\",   data = list(i_diamonds_data) ~ \"A nested data column must be specified as a list\",   .groups = FALSE )  i_diamonds_data = interfacer::iface(   carat = numeric ~ \"the carat column\",   depth = numeric ~ \"the depth column\",   table = numeric ~ \"the table column\",   price = integer ~ \"the price column\",   x = numeric ~ \"the x column\",   y = numeric ~ \"the y column\",   z = numeric ~ \"the z column\",   .groups = FALSE )  nested_diamonds = ggplot2::diamonds %>%   tidyr::nest(data = c(-cut,-color,-clarity))  nested_diamonds %>% iconvert(i_diamonds_cat) %>% dplyr::glimpse() #> Rows: 276 #> Columns: 4 #> $ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver… #> $ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, I, E, G,… #> $ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, … #> $ data    <list> [<tbl_df[469 x 7]>], [<tbl_df[614 x 7]>], [<tbl_df[89 x 7]>],…"},{"path":"/articles/interfacer.html","id":"developer-tools","dir":"Articles","previous_headings":"","what":"Developer tools","title":"interfacer","text":"TBD: iclip(diamonds) use_dataframe(iris) use_iface(diamonds)","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rob Challen. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2023). interfacer: Define Enforce Interface Contracts Dataframes. R package version 0.1.2.","code":"@Manual{,   title = {interfacer: Define and Enforce Interface Contracts for Dataframes},   author = {Rob Challen},   year = {2023},   note = {R package version 0.1.2}, }"},{"path":"/index.html","id":"interfacer","dir":"","previous_headings":"","what":"Define and Enforce Interface Contracts for Dataframes","title":"Define and Enforce Interface Contracts for Dataframes","text":"Interfacer primarily aimed R package developers. provides framework specifying structure dataframes parameters user functions checking user supplied dataframes conform expectations. Missing columns incorrectly typed columns can identified useful error messages returned. Specifying structure part function definition can automatically included Roxygen documentation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Define and Enforce Interface Contracts for Dataframes","text":"package hosted Bristol Vaccine Centre r-universe. Installation follows: can install development version interfacer GitHub : likely though including another package via DESCRIPTION file:","code":"options(repos = c(   \"bristol-vaccine-centre\" = 'https://https://bristol-vaccine-centre.r-universe.dev/',   CRAN = 'https://cloud.r-project.org'))  # Download and install interfacer in R install.packages(\"interfacer\") # install.packages(\"devtools\") devtools::install_github(\"bristol-vaccine-centre/interfacer\") ... Imports:      tidyverse,     interfacer Remotes: github::bristol-vaccine-centre/interfacer Suggests:      knitr,     rmarkdown ..."},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Define and Enforce Interface Contracts for Dataframes","text":"interfacer used within function definition new package constrain input function particular shape.","code":"#' An example function #' #' @param mydata `r interfacer::idocument(example_fn, mydata)` #' @param another an example    #' @param ... not used #' #' @return ... something not yet defined ... #' @export example_fn = function(      # this parameter will be a dataframe with id and test columns   mydata = interfacer::iface(     id = integer + group_unique ~ \"an integer ID\",     test = logical ~ \"the test result\"   ),      another = \"value\",   ...    ) {   # this line enforces the `iface` rules for the dataframe, coercing columns   # if possible and throwing helpful errors if not.   mydata = interfacer::ivalidate(mydata, ...)   # rest of function body ... }"},{"path":"/reference/as.list.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast an iface to a plain list. — as.list.iface","title":"Cast an iface to a plain list. — as.list.iface","text":"Cast iface plain list.","code":""},{"path":"/reference/as.list.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast an iface to a plain list. — as.list.iface","text":"","code":"# S3 method for iface as.list(x, ..., flatten = FALSE)"},{"path":"/reference/as.list.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast an iface to a plain list. — as.list.iface","text":"x object coerced tested. ... objects, possibly named. flatten get list lists representation instead dataframe column column list.","code":""},{"path":"/reference/as_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"Reuse tidy-select syntax outside tidy-select function","code":""},{"path":"/reference/as_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"","code":"as_vars(tidyselect, data = NULL)"},{"path":"/reference/as_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"tidyselect tidyselect syntax evaluated context looking call call stack includes dataframe first argument data (optional) specific dataframe evaluate tidyselect","code":""},{"path":"/reference/as_vars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reuse tidy-select syntax outside of a tidy-select function — as_vars","text":"list symbols resulting evaluation tidyselect context current call stack (provided data frame)","code":""},{"path":"/reference/enum.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to match a factor with specific levels. — enum","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"Define conformance rule match factor specific levels.","code":""},{"path":"/reference/enum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"","code":"enum(..., .drop = FALSE)"},{"path":"/reference/enum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"... levels (quotes, backticks required) .drop levels present data specified cause error (FALSE default) silently dropped NA values (TRUE).","code":""},{"path":"/reference/enum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"function can check convert input factor specified levels. re-level factors matching levels different order.","code":""},{"path":"/reference/enum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to match a factor with specific levels. — enum","text":"","code":"f = enum(one,two,three) f(c(\"three\",\"two\",\"one\")) #> [1] three two   one   #> Levels: one two three f(factor(rep(1:3,5), labels = c(\"one\",\"two\",\"three\"))) #>  [1] one   two   three one   two   three one   two   three one   two   three #> [13] one   two   three #> Levels: one two three"},{"path":"/reference/format.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Format an iface specification for printing — format.iface","title":"Format an iface specification for printing — format.iface","text":"Format iface specification printing","code":""},{"path":"/reference/format.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format an iface specification for printing — format.iface","text":"","code":"# S3 method for iface format(x, ...)"},{"path":"/reference/format.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format an iface specification for printing — format.iface","text":"x R object (conceptually); typically numeric. ... arguments passed methods.","code":""},{"path":"/reference/format.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format an iface specification for printing — format.iface","text":"","code":"my_iface = iface(    col1 = integer + group_unique ~ \"an integer column\" )  print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> No mandatory groupings. #> No default value. knitr::knit_print(my_iface) #> [1] \"A dataframe containing the following columns: \\n- col1 (integer + group_unique) - an integer column\\n\\nNo mandatory groupings.\\n\\nNo default value.\" #> attr(,\"class\") #> [1] \"knit_asis\""},{"path":"/reference/iclip.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an iface interface from an example dataframe — iclip","title":"Create an iface interface from an example dataframe — iclip","text":"Copies iface specification clipboard","code":""},{"path":"/reference/iclip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an iface interface from an example dataframe — iclip","text":"","code":"iclip(df, df_name = deparse(substitute(df)))"},{"path":"/reference/iclip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an iface interface from an example dataframe — iclip","text":"df prototype dataframe df_name optional name parameter","code":""},{"path":"/reference/iclip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an iface interface from an example dataframe — iclip","text":"nothing","code":""},{"path":"/reference/iclip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an iface interface from an example dataframe — iclip","text":"","code":"if(FALSE) iclip(iris)"},{"path":"/reference/iconvert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a dataframe to a format compatible with an interface specification — iconvert","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"function called ivalidate generally intended used directly end user. may helpful debugging package development interactive test iface spec.","code":""},{"path":"/reference/iconvert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"","code":"iconvert(   df,   iface,   .imap = interfacer::imapper(),   .dname = \"<unknown>\",   .fname = \"<unknown>\",   .has_dots = TRUE,   .prune = FALSE,   .env = rlang::current_env() )"},{"path":"/reference/iconvert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"df dataframe convert iface interface spec iface .imap optional imapper mapping .dname name parameter value (optional). .fname name function (optional). .has_dots internal library use . Changes nature error message. .prune want remove non matching columns? .env internal use ","code":""},{"path":"/reference/iconvert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"conformant dataframe","code":""},{"path":"/reference/iconvert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a dataframe to a format compatible with an interface specification — iconvert","text":"","code":"i_diamonds = iface(    color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",    price = integer ~ \"the price\" ) iconvert(ggplot2::diamonds, i_diamonds,.prune = TRUE) #> # A tibble: 53,940 × 2 #>    color price #>    <fct> <int> #>  1 E       326 #>  2 E       326 #>  3 E       327 #>  4 I       334 #>  5 J       335 #>  6 J       336 #>  7 I       336 #>  8 H       337 #>  9 E       337 #> 10 H       338 #> # ℹ 53,930 more rows"},{"path":"/reference/idispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"multiple possible dataframe formats possible function, different processing requirements decision can made based validation input set rules. first matching rule used process function.","code":""},{"path":"/reference/idispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"","code":"idispatch(x, ..., .default = NULL)"},{"path":"/reference/idispatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"x dataframe ... set function name=interfacer::iface pairs .default function apply situation none rules can matched. default results error thrown.","code":""},{"path":"/reference/idispatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"result dispatching dataframe first function matches rules .... Matching permissive test passed dataframe can coerced iface specified format.","code":""},{"path":"/reference/idispatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dispatch to a named function based on the characteristics of a dataframe — idispatch","text":"","code":"i1 = iface( col1 = integer ~ \"An integer column\" ) i2 = iface( col2 = integer ~ \"A different integer column\" )  # this is the structure for the function that woudl be exported extract_mean = function(df, ...) {   idispatch(df,     extract_mean.i1 = i1,     extract_mean.i2 = i2   ) }  # this is expected to be an internal package function # the naming convention here is based on S3 but it is not required extract_mean.i1 = function(df = i1, ...) {   message(\"using i1\")   # validation is not strictly required in this as it will already have been    # done unless this is an exported function   df = ivalidate(df)   mean(df$col1) }  extract_mean.i2 = function(df = i2, uplift = 1, ...) {   message(\"using i2\")   df = ivalidate(df)   mean(df$col2)+uplift }  test = tibble::tibble( col2 = 1:10 ) extract_mean(test, uplift = 50) #> using i2 #> [1] 55.5  test2 = tibble::tibble( col1 = 1:10 ) extract_mean(test2, uplift = 50) #> using i1 #> [1] 5.5"},{"path":"/reference/idocument.html","id":null,"dir":"Reference","previous_headings":"","what":"Document an interface contract for inserting into roxygen — idocument","title":"Document an interface contract for inserting into roxygen — idocument","text":"function expected called within documentation function inline code parameter documentation function. details expected columns input dataframe possess.","code":""},{"path":"/reference/idocument.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Document an interface contract for inserting into roxygen — idocument","text":"","code":"idocument(fn, param = NULL)"},{"path":"/reference/idocument.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Document an interface contract for inserting into roxygen — idocument","text":"fn function documenting param parameter documenting (optional. missing defaults first argument function)","code":""},{"path":"/reference/idocument.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Document an interface contract for inserting into roxygen — idocument","text":"markdown snippet","code":""},{"path":"/reference/idocument.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Document an interface contract for inserting into roxygen — idocument","text":"","code":"#' @param df `r idocument(x, df)` x = function(df = iface( col1 = integer ~ \"an integer column\" )) {}  cat(idocument(x, df)) #> A dataframe containing the following columns:  #> - col1 (integer) - an integer column #>  #> No mandatory groupings. #>  #> No default value."},{"path":"/reference/if_col_present.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a function or return a value if a column in present in a dataframe — if_col_present","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"simple use case. complex behaviour see switch_pipeline().","code":""},{"path":"/reference/if_col_present.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"","code":"if_col_present(df, col, if_present, if_missing = ~.x)"},{"path":"/reference/if_col_present.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"df dataframe col column name if_present purrr style function execute dataframe column present (plain value) if_missing purrr style function execute dataframe column missing (plain value)","code":""},{"path":"/reference/if_col_present.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"either value if_present/if_absent result calling if_present/if_absent functions df.","code":""},{"path":"/reference/if_col_present.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute a function or return a value if a column in present in a dataframe — if_col_present","text":"","code":"iris %>% if_col_present(Species, ~ .x %>% dplyr::rename(new = Species)) %>%   colnames() #> [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"new\"           # in contrast to purrr absolute values are not interpreted as function names   iris %>% if_col_present(Species2, \"Yes\", \"No\") #> [1] \"No\""},{"path":"/reference/iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Define an interface — iface","title":"Define an interface — iface","text":"iface function allows us define structure dataframe terms columns column types. iface specification used define type formal parameter function, parameters default value. definition picked ivalidate(...) used within function ensure input correctly formatted. interface spec may also used ireturn(...) enforce output function correct.","code":""},{"path":"/reference/iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define an interface — iface","text":"","code":"iface(..., .groups = NULL, .default = NULL)"},{"path":"/reference/iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define an interface — iface","text":"... specification interface (see details), unnamed iface object extend, . .groups either FALSE grouping allowed formula form ~ var1 + var2 + ... defines columns must grouped dataframe (order). NULL (default) grouping permitted. formula contains dot e.g. ~ . + var1 + var2 grouping must include var1 var2 groups also allowed. .default default value supply nothing given function parameter using iface formal. either NULL case default, TRUE case default zero row tibble conforming spec, provided dataframe, checked conform, used default.","code":""},{"path":"/reference/iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define an interface — iface","text":"definition interface iface object","code":""},{"path":"/reference/iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define an interface — iface","text":"iface definitions can printed included roxygen documentation help us document input dataframe parameters dataframe return values standardised way. specification form named list formulae structure name = type ~ \"documentation\". type can one anything, character, complete, date, default, double, enum, factor, finite, group_unique, in_range, integer, logical, not_missing, numeric, positive_double, positive_integer, proportion (e.g. enum(level1,level2,...), in_range(min,max)) anything resolves function e.g. .ordered. type function name, function must take single vector parameter return single vector size. function must also return zero length vector appropriate type passed NULL. type can also concatenation rules separated +, e.g. integer + group_unique integer unique within group.","code":""},{"path":"/reference/iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define an interface — iface","text":"","code":"test_df = tibble::tibble(   grp = c(rep(\"a\",10),rep(\"b\",10)),    col1 = c(1:10,1:10) ) %>% dplyr::group_by(grp)  my_iface = iface(    col1 = integer + group_unique ~ \"an integer column\",   .default = test_df )  print(my_iface) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> No mandatory groupings. #> A default value is defined.  # the function x defines a formal `df` with default value of `my_iface` x = function(df = my_iface, ...) {   df = ivalidate(df,...)   return(df) }  # this works x(tibble::tibble(col1 = c(1,2,3))) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3  # this fails as x is of the wrong type try(x(tibble::tibble(col1 = c(\"a\",\"b\",\"c\")))) #> Error in dplyr::mutate(., `:=`(!!data_col, asfn2(!!data_col))) :  #>   ℹ In argument: `col1 = asfn2(col1)`. #> Caused by error: #> ! input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer + group_unique: NAs introduced by coercion  # this fails as x has duplicates try(x(tibble::tibble(col1 = c(1,2,3,3)))) #> Error in dplyr::mutate(., `:=`(!!data_col, asfn2(!!data_col))) :  #>   ℹ In argument: `col1 = asfn2(col1)`. #> Caused by error: #> ! input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer + group_unique: non unique values detected  # this gives the default value x() #> # A tibble: 20 × 2 #> # Groups:   grp [2] #>    grp    col1 #>    <chr> <int> #>  1 a         1 #>  2 a         2 #>  3 a         3 #>  4 a         4 #>  5 a         5 #>  6 a         6 #>  7 a         7 #>  8 a         8 #>  9 a         9 #> 10 a        10 #> 11 b         1 #> 12 b         2 #> 13 b         3 #> 14 b         4 #> 15 b         5 #> 16 b         6 #> 17 b         7 #> 18 b         8 #> 19 b         9 #> 20 b        10   my_iface2 = iface(my_iface, col2 = character ~ \"another col\", .groups = ~ col1 + col2) print(my_iface2) #> A dataframe containing the following columns:  #> * col1 (integer + group_unique) - an integer column #> * col2 (character) - another col #> Must be grouped by: col1 + col2 (exactly). #> No default value."},{"path":"/reference/igroup_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle unexpected additional grouping structure — igroup_process","title":"Handle unexpected additional grouping structure — igroup_process","text":"function designed used package author within enclosing function. enclosing function assumed take input dataframe iface specified dataframe.","code":""},{"path":"/reference/igroup_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle unexpected additional grouping structure — igroup_process","text":"","code":"igroup_process(df = NULL, fn, ...)"},{"path":"/reference/igroup_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle unexpected additional grouping structure — igroup_process","text":"df dataframe enclosing function grouping may may correctly supplied. fn function call correctly grouped dataframe specified iface enclosing function. ... passed onto iconvert used supply .imap .prune parameters. triple dot parameters enclosing function separately handled automatically passed fn general passed igroup_process intermediary although probably hurt. behaviour similar NextMethod S3 method dispatch.","code":""},{"path":"/reference/igroup_process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle unexpected additional grouping structure — igroup_process","text":"result calling fn(df, ...)","code":""},{"path":"/reference/igroup_process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Handle unexpected additional grouping structure — igroup_process","text":"function detects grouping input additional groups specification intercepts , regrouping dataframe applying fn groupwise using equivalent group_modify. parameters provided enclosing function passed fn compatible method signatures.","code":""},{"path":"/reference/igroup_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Handle unexpected additional grouping structure — igroup_process","text":"","code":"i_diamond_price = interfacer::iface(   color = enum(`D`,`E`,`F`,`G`,`H`,`I`,`J`, .ordered=TRUE) ~ \"the color column\",   price = integer ~ \"the price column\",   .groups = ~ color )  # exported function in package # at param can use `r idocument(ex_mean, df)` for documentation ex_mean = function(df = i_diamond_price, extra_param = \".\") {      # dispatch based on groupings:   igroup_process(df,           # the real work of this function is provided as an anonymous inner     # function (but can be any other function e.g. package private function)     # or a purrr style lambda.          function(df, extra_param) {       message(extra_param, appendLF = FALSE)       return(df %>% dplyr::summarise(mean_price = mean(price)))     }        ) }  # The correctly grouped dataframe ggplot2::diamonds %>%    dplyr::group_by(color) %>%    ex_mean(extra_param = \"without additional groups...\") %>%    dplyr::glimpse() #> without additional groups... #> Rows: 7 #> Columns: 2 #> $ color      <ord> D, E, F, G, H, I, J #> $ mean_price <dbl> 3169.954, 3076.752, 3724.886, 3999.136, 4486.669, 5091.875,…    # The incorrectly grouped dataframe ggplot2::diamonds %>%    dplyr::group_by(cut, color, clarity) %>%    ex_mean() %>%    dplyr::glimpse() #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> . #> Rows: 276 #> Columns: 4 #> Groups: cut, clarity [40] #> $ cut        <ord> Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair, Fair,… #> $ clarity    <ord> I1, I1, I1, I1, I1, I1, I1, SI2, SI2, SI2, SI2, SI2, SI2, S… #> $ color      <ord> D, E, F, G, H, I, J, D, E, F, G, H, I, J, D, E, F, G, H, I,… #> $ mean_price <dbl> 7383.000, 2095.222, 2543.514, 3187.472, 4212.962, 3501.000,… # The output of this is actually grouped by cut then clarity as # color is consumed by the igroup_dispatch summarise."},{"path":"/reference/imap.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify mappings that can make dataframes compatible with an interface — imap","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"function expected used .imap = imap(...) context overcome mapping issues","code":""},{"path":"/reference/imap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"imap(...)"},{"path":"/reference/imap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"... set dplyr::mutate() specifications applied dataframe rename otherwise fix missing columns","code":""},{"path":"/reference/imap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"set mappings","code":""},{"path":"/reference/imap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify mappings that can make dataframes compatible with an interface — imap","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...) } input=tibble::tibble(col2 = c(1,2,3))  # This fails because col1 is missing try(x(input)) #> Error in iconvert(df, spec, .imap, dname, .get_fn_name(fn), .has_dots,  :  #>   1 missing columns in parameter `df` in call to x(...) #> consider renaming to create `col1` columns #> or by adding `.imap = interfacer::imap(`col1` = ???)` to your function call. #>  # This fixes it for this input x(input, .imap=imap(col1 = col2))"},{"path":"/reference/imapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify mappings that can make dataframes compatible with an interface — imapper","title":"Specify mappings that can make dataframes compatible with an interface — imapper","text":"function expected used .imap = imappper(...) context overcome mapping issues","code":""},{"path":"/reference/imapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify mappings that can make dataframes compatible with an interface — imapper","text":"","code":"imapper(...)"},{"path":"/reference/imapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify mappings that can make dataframes compatible with an interface — imapper","text":"... set dplyr::mutate() specifications applied dataframe rename otherwise fix missing columns","code":""},{"path":"/reference/imapper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify mappings that can make dataframes compatible with an interface — imapper","text":"set mappings","code":""},{"path":"/reference/imapper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify mappings that can make dataframes compatible with an interface — imapper","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(df,...) } input=tibble::tibble(col2 = c(1,2,3))  # This fails because col1 is missing try(x(input)) #> Error : missing columns in the `df` parameter of x(..). #> missing: col1 #> consider renaming / creating missing columns before calling `x`(...) #> or by adding `.imap = interfacer::imapper(`col1`=...)` to your function call. #>  # This fixes it for this input x(input, .imap=imapper(col1 = col2))"},{"path":"/reference/in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to confirm that a numeric is in a set range — in_range","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"anticipated part iface rule e.g.","code":""},{"path":"/reference/in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"","code":"in_range(min, max)"},{"path":"/reference/in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"min lower limit (inclusive) max upper limit (inclusive)","code":""},{"path":"/reference/in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"function checks values returns OK throws error ","code":""},{"path":"/reference/in_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"iface(test_col = integer + in_range(-10,10) ~ \"integer -10 10\")","code":""},{"path":"/reference/in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to confirm that a numeric is in a set range — in_range","text":"","code":"in_range(0,100)(1:99) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #> [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #> [76] 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 try(in_range(0,10)(1:99)) #> Error in in_range(0, 10)(1:99) : values not in range: 0-10"},{"path":"/reference/iproto.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a zero length tibble conforming to a spec — iproto","title":"Generate a zero length tibble conforming to a spec — iproto","text":"Generate zero length tibble conforming spec","code":""},{"path":"/reference/iproto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a zero length tibble conforming to a spec — iproto","text":"","code":"iproto(iface)"},{"path":"/reference/iproto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a zero length tibble conforming to a spec — iproto","text":"iface specification","code":""},{"path":"/reference/iproto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a zero length tibble conforming to a spec — iproto","text":"tibble conforming iface","code":""},{"path":"/reference/iproto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a zero length tibble conforming to a spec — iproto","text":"","code":"i = interfacer::iface(   col1 = integer ~ \"A number\",   col2 = character ~ \"A string\" )  iproto(i) #> # A tibble: 0 × 2 #> # ℹ 2 variables: col1 <int>, col2 <chr>"},{"path":"/reference/ireturn.html","id":null,"dir":"Reference","previous_headings":"","what":"Check a return parameter from a function — ireturn","title":"Check a return parameter from a function — ireturn","text":"intended used within function check validity data frame returned function ispec provided.","code":""},{"path":"/reference/ireturn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check a return parameter from a function — ireturn","text":"","code":"ireturn(df, iface, .prune = FALSE)"},{"path":"/reference/ireturn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check a return parameter from a function — ireturn","text":"df dataframe - missing first parameter calling function assumed dataframe. iface interface specification df conform . .prune get rid excess columns spec.","code":""},{"path":"/reference/ireturn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check a return parameter from a function — ireturn","text":"dataframe based df validity checks passed .imap mappings applied present","code":""},{"path":"/reference/ireturn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check a return parameter from a function — ireturn","text":"","code":"input = iface(col_in = integer ~ \"an integer column\" ) output = iface(col_out = integer ~ \"an integer column\" ) x = function(df = input, ...) {   df = ivalidate(...)   tmp = df %>% dplyr::rename(col_out = col_in)   ireturn(tmp, output) } x(tibble::tibble(col_in = c(1,2,3))) #> # A tibble: 3 × 1 #>   col_out #>     <int> #> 1       1 #> 2       2 #> 3       3 output #> A dataframe containing the following columns:  #> * col_out (integer) - an integer column #> No mandatory groupings. #> No default value."},{"path":"/reference/is.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an object is an interface spec — is.iface","title":"Check if an object is an interface spec — is.iface","text":"Check object interface spec","code":""},{"path":"/reference/is.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an object is an interface spec — is.iface","text":"","code":"is.iface(x, ...)"},{"path":"/reference/is.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an object is an interface spec — is.iface","text":"x parameter check ... ignored","code":""},{"path":"/reference/is.iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an object is an interface spec — is.iface","text":"boolean.","code":""},{"path":"/reference/is_col_present.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for existence of a set of columns in a dataframe — is_col_present","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"Check existence set columns dataframe","code":""},{"path":"/reference/is_col_present.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"","code":"is_col_present(df, ...)"},{"path":"/reference/is_col_present.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"df dataframe test ... column names (unquoted)","code":""},{"path":"/reference/is_col_present.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"TRUE columns , false otherwise","code":""},{"path":"/reference/is_col_present.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for existence of a set of columns in a dataframe — is_col_present","text":"","code":"is_col_present(iris, Species, Petal.Width) #> [1] TRUE"},{"path":"/reference/itest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test dataframe conformance to an interface specification. — itest","title":"Test dataframe conformance to an interface specification. — itest","text":"ivalidate throws errors deliberately however sometimes dealing invalid input may desirable. itest generally designed used within function specifies expected input using iface, allows function test given input conformant interface.","code":""},{"path":"/reference/itest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test dataframe conformance to an interface specification. — itest","text":"","code":"itest(df = NULL, iface = NULL, .imap = imapper())"},{"path":"/reference/itest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test dataframe conformance to an interface specification. — itest","text":"df dataframe test. missing first parameter calling function assumed dataframe test. iface interface specification produced iface(). missing inferred current function signature. .imap optional mapping specification produced imapper()","code":""},{"path":"/reference/itest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test dataframe conformance to an interface specification. — itest","text":"TRUE dataframe conformant, FALSE otherwise","code":""},{"path":"/reference/itest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test dataframe conformance to an interface specification. — itest","text":"","code":"if (rlang::is_installed(\"ggplot2\")) {   i_diamonds = iface(      color = enum(D,E,F,G,H,I,J,extra) ~ \"the colour\",      price = integer ~ \"the price\"   )      # Ad hoc testing   itest(ggplot2::diamonds, i_diamonds)      # Use within function:   x = function(df = i_diamonds) {     if(itest()) message(\"PASS!\")   }      x(ggplot2::diamonds) } #> PASS!"},{"path":"/reference/ivalidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"ivalidate(...) intended used within function check validity data frame parameter (usually first parameter) ispec given default value formal parameter.","code":""},{"path":"/reference/ivalidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"","code":"ivalidate(df = NULL, ..., .imap = imapper(), .prune = FALSE, .default = NULL)"},{"path":"/reference/ivalidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"df dataframe - missing first parameter calling function assumed dataframe. ... used ivalidate included call inherit .imap caller function. .imap set mappings imapper object. .prune get rid excess columns spec. .default default dataframe conforming specification. overrides defaults defined interface specification","code":""},{"path":"/reference/ivalidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"dataframe based df validity checks passed .imap mappings applied present","code":""},{"path":"/reference/ivalidate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform interface checks on dataframe by looking at enclosing function formals — ivalidate","text":"","code":"x = function(df = iface(col1 = integer ~ \"an integer column\" ), ...) {   df = ivalidate(...)   return(df) } input=tibble::tibble(col1 = c(1,2,3)) x(input) #> # A tibble: 3 × 1 #>    col1 #>   <int> #> 1     1 #> 2     2 #> 3     3  # This fails because col1 is not coercable to integer input2=tibble::tibble(col1 = c(1.5,2,3)) try(x(input2)) #> Error in dplyr::mutate(., `:=`(!!data_col, asfn2(!!data_col))) :  #>   ℹ In argument: `col1 = asfn2(col1)`. #> Caused by error: #> ! input column `col1` in function parameter `x(df = ?)` cannot be coerced to a integer: not a true integer input"},{"path":"/reference/knit_print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"A custom printing function — knit_print.iface","title":"A custom printing function — knit_print.iface","text":"S3 generic function knit_print default printing function knitr. chunk option render uses function default. main purpose S3 generic function customize printing R objects code chunks. can fall back normal printing behavior setting chunk option render = normal_print.","code":""},{"path":"/reference/knit_print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A custom printing function — knit_print.iface","text":"","code":"# S3 method for iface knit_print(x, ...)"},{"path":"/reference/knit_print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A custom printing function — knit_print.iface","text":"x R object printed ... Additional arguments passed S3 method. Currently ignored, except two optional arguments options inline; see references .","code":""},{"path":"/reference/knit_print.iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A custom printing function — knit_print.iface","text":"value returned print method character vector   can converted character value. can wrap value  asis_output() knitr writes character value   output.","code":""},{"path":"/reference/knit_print.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A custom printing function — knit_print.iface","text":"Users can write custom methods based generic function. example, want print data frames tables output, can define method knit_print.data.frame turns data.frame table (implementation may use R packages functions, e.g. xtable kable()).","code":""},{"path":"/reference/knit_print.iface.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"A custom printing function — knit_print.iface","text":"recommended leave ... argument method,   allow future changes knit_print() API without breaking   method.","code":""},{"path":"/reference/knit_print.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A custom printing function — knit_print.iface","text":"See vignette('knit_print', package = 'knitr').","code":""},{"path":"/reference/knit_print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A custom printing function — knit_print.iface","text":"","code":"library(knitr) # write tables for data frames knit_print.data.frame = function(x, ...) {     res = paste(c(\"\", \"\", kable(x, output = FALSE)), collapse = \"\\n\")     asis_output(res) } # register the method registerS3method(\"knit_print\", \"data.frame\", knit_print.data.frame) # after you define and register the above method, data frames will be printed # as tables in knitr, which is different with the default print() behavior"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/print.iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Values — print.iface","title":"Print Values — print.iface","text":"print prints argument returns invisibly (via   invisible(x)).  generic function means   new printing methods can easily added new classes.","code":""},{"path":"/reference/print.iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Values — print.iface","text":"","code":"# S3 method for iface print(x, ...)"},{"path":"/reference/print.iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Values — print.iface","text":"x object used select method. ... arguments passed methods.","code":""},{"path":"/reference/print.iface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print Values — print.iface","text":"default method, print.default help page.   Use methods(\"print\") get methods   print generic. print.factor allows customization used printing   ordered factors well. print.table printing tables allows   customization.  R 3.0.0, prints description case table   0-extents (can happen classifier valid data). See noquote example class whose main   purpose specific print method.","code":""},{"path":"/reference/print.iface.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Print Values — print.iface","text":"Chambers, J. M. Hastie, T. J. (1992)   Statistical Models S.   Wadsworth & Brooks/Cole.","code":""},{"path":[]},{"path":"/reference/print.iface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Values — print.iface","text":"","code":"require(stats)  ts(1:20)  #-- print is the \"Default function\" --> print.ts(.) is called #> Time Series: #> Start = 1  #> End = 20  #> Frequency = 1  #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 for(i in 1:3) print(1:i) #> [1] 1 #> [1] 1 2 #> [1] 1 2 3  ## Printing of factors attenu$station ## 117 levels -> 'max.levels' depending on width #>   [1] 117  1083 1095 283  135  475  113  1008 1028 2001 117  1117 1438 1083 1013 #>  [16] 1014 1015 1016 1095 1011 1028 270  280  116  266  117  113  112  130  475  #>  [31] 269  135  1093 1093 111  116  290  112  113  128  126  127  141  266  110  #>  [46] 1027 111  125  135  475  262  269  1052 411  290  130  272  1096 1102 112  #>  [61] 113  1028 2714 2708 2715 3501 655  272  1032 1377 1028 1250 1051 1293 1291 #>  [76] 1292 283  885  <NA> 2734 <NA> 2728 1413 1445 1408 1411 1410 1409 1377 1492 #>  [91] 1251 1422 1376 <NA> 286  <NA> 5028 942  <NA> 5054 958  952  5165 117  955  #> [106] 5055 <NA> <NA> 5060 412  5053 5058 5057 <NA> 5051 <NA> 5115 <NA> 931  5056 #> [121] 5059 5061 <NA> 5062 5052 <NA> 724  <NA> 5066 5050 2316 5055 942  5028 5165 #> [136] 952  958  955  117  412  5053 5054 5058 5057 5115 5056 5060 1030 1418 1383 #> [151] 1308 1298 1299 1219 <NA> <NA> 1030 1418 1383 <NA> 1299 1308 1219 1456 5045 #> [166] 5044 5160 5043 5047 c168 5068 c118 5042 5067 5049 c204 5070 c266 c203 5069 #> [181] 5073 5072 #> 117 Levels: 1008 1011 1013 1014 1015 1016 1027 1028 1030 1032 1051 1052 ... c266  ## ordered factors: levels  \"l1 < l2 < ..\" esoph$agegp[1:12] #>  [1] 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 25-34 #> Levels: 25-34 < 35-44 < 45-54 < 55-64 < 65-74 < 75+ esoph$alcgp[1:12] #>  [1] 0-39g/day 0-39g/day 0-39g/day 0-39g/day 40-79     40-79     40-79     #>  [8] 40-79     80-119    80-119    80-119    120+      #> Levels: 0-39g/day < 40-79 < 80-119 < 120+  ## Printing of sparse (contingency) tables set.seed(521) t1 <- round(abs(rt(200, df = 1.8))) t2 <- round(abs(rt(200, df = 1.4))) table(t1, t2) # simple #>     t2 #> t1    0  1  2  3  4  5  6  7  8 10 17 21 30 #>   0  21 22 14  4  1  0  1  1  1  0  1  0  0 #>   1  25 21  7  3  4  2  1  1  1  1  0  0  0 #>   2   8 16  9  2  0  0  0  0  0  0  0  1  1 #>   3   3  7  0  2  0  0  0  0  0  0  0  0  0 #>   4   1  5  2  0  0  0  1  0  0  0  0  0  0 #>   5   1  1  1  0  0  0  0  0  0  0  0  0  0 #>   6   1  3  0  0  0  0  0  0  0  0  0  0  0 #>   7   1  0  0  0  0  0  0  0  0  0  0  0  0 #>   9   0  0  0  1  0  0  0  0  0  0  0  0  0 #>   12  1  0  0  0  0  0  0  0  0  0  0  0  0 print(table(t1, t2), zero.print = \".\") # nicer to read #>     t2 #> t1    0  1  2  3  4  5  6  7  8 10 17 21 30 #>   0  21 22 14  4  1  .  1  1  1  .  1  .  . #>   1  25 21  7  3  4  2  1  1  1  1  .  .  . #>   2   8 16  9  2  .  .  .  .  .  .  .  1  1 #>   3   3  7  .  2  .  .  .  .  .  .  .  .  . #>   4   1  5  2  .  .  .  1  .  .  .  .  .  . #>   5   1  1  1  .  .  .  .  .  .  .  .  .  . #>   6   1  3  .  .  .  .  .  .  .  .  .  .  . #>   7   1  .  .  .  .  .  .  .  .  .  .  .  . #>   9   .  .  .  1  .  .  .  .  .  .  .  .  . #>   12  1  .  .  .  .  .  .  .  .  .  .  .  .  ## same for non-integer \"table\": T <- table(t2,t1) T <- T * (1+round(rlnorm(length(T)))/4) print(T, zero.print = \".\") # quite nicer, #>     t1 #> t2       0     1     2     3     4     5     6     7     9    12 #>   0  26.25 25.00 10.00  3.75  1.50  1.25  1.25  1.00     .  2.00 #>   1  22.00 26.25 16.00 10.50 27.50  1.25  3.00     .     .     . #>   2  21.00  7.00 13.50     .  3.00  1.25     .     .     .     . #>   3   5.00  3.75  2.50  2.50     .     .     .     .  1.50     . #>   4   1.25  5.00     .     .     .     .     .     .     .     . #>   5      .  2.00     .     .     .     .     .     .     .     . #>   6   1.25  1.50     .     .  1.25     .     .     .     .     . #>   7   1.25  1.25     .     .     .     .     .     .     .     . #>   8   1.50  1.00     .     .     .     .     .     .     .     . #>   10     .  1.00     .     .     .     .     .     .     .     . #>   17  1.00     .     .     .     .     .     .     .     .     . #>   21     .     .  2.75     .     .     .     .     .     .     . #>   30     .     .  5.00     .     .     .     .     .     .     . print.table(T[,2:8] * 1e9, digits=3, zero.print = \".\") #>     t1 #> t2          1        2        3        4        5        6        7 #>   0  2.50e+10 1.00e+10 3.75e+09 1.50e+09 1.25e+09 1.25e+09 1.00e+09 #>   1  2.62e+10 1.60e+10 1.05e+10 2.75e+10 1.25e+09 3.00e+09        . #>   2  7.00e+09 1.35e+10        . 3.00e+09 1.25e+09        .        . #>   3  3.75e+09 2.50e+09 2.50e+09        .        .        .        . #>   4  5.00e+09        .        .        .        .        .        . #>   5  2.00e+09        .        .        .        .        .        . #>   6  1.50e+09        .        . 1.25e+09        .        .        . #>   7  1.25e+09        .        .        .        .        .        . #>   8  1.00e+09        .        .        .        .        .        . #>   10 1.00e+09        .        .        .        .        .        . #>   17        .        .        .        .        .        .        . #>   21        . 2.75e+09        .        .        .        .        . #>   30        . 5.00e+09        .        .        .        .        . ## still slightly inferior to  Matrix::Matrix(T)  for larger T  ## Corner cases with empty extents: table(1, NA) # < table of extent 1 x 0 > #> < table of extent 1 x 0 >"},{"path":"/reference/switch_pipeline.html","id":null,"dir":"Reference","previous_headings":"","what":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"Branch dplyr pipeline based set conditions","code":""},{"path":"/reference/switch_pipeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"","code":"switch_pipeline(.x, ...)"},{"path":"/reference/switch_pipeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":".x dataframe ... list formulae type predicate ~ purrr function using .x single parameter","code":""},{"path":"/reference/switch_pipeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"result applying purrr function .x case predicate evaluates true. bothe predicate function can refer pipeline dataframe using .x","code":""},{"path":"/reference/switch_pipeline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branch a dplyr pipeline based on a set of conditions — switch_pipeline","text":"","code":"iris %>% switch_pipeline(   is_col_present(.x, Species) ~ .x %>% dplyr::rename(new = Species) ) %>% dplyr::glimpse() #> Rows: 150 #> Columns: 5 #> $ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.… #> $ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.… #> $ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.… #> $ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.… #> $ new          <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…"},{"path":"/reference/type.anything.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce a unspecified type — type.anything","title":"Coerce a unspecified type — type.anything","text":"Coerce unspecified type","code":""},{"path":"/reference/type.anything.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce a unspecified type — type.anything","text":"","code":"type.anything(x)"},{"path":"/reference/type.anything.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce a unspecified type — type.anything","text":"x vector","code":""},{"path":"/reference/type.anything.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce a unspecified type — type.anything","text":"input (unless x NULL case character())","code":""},{"path":"/reference/type.character.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a character. — type.character","title":"Coerce to a character. — type.character","text":"Coerce character.","code":""},{"path":"/reference/type.character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a character. — type.character","text":"","code":"type.character()"},{"path":"/reference/type.character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a character. — type.character","text":"input character.","code":""},{"path":"/reference/type.complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a complete set of values. — type.complete","title":"Coerce to a complete set of values. — type.complete","text":"Coerce complete set values.","code":""},{"path":"/reference/type.complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a complete set of values. — type.complete","text":"","code":"type.complete(x)"},{"path":"/reference/type.complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a complete set of values. — type.complete","text":"x vector, factor numeric","code":""},{"path":"/reference/type.complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a complete set of values. — type.complete","text":"input, error factor levels present, numerics sequence minimum maximum smallest difference approximately present.","code":""},{"path":"/reference/type.date.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a Date. — type.date","title":"Coerce to a Date. — type.date","text":"Coerce Date.","code":""},{"path":"/reference/type.date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a Date. — type.date","text":"","code":"type.date(x, ...)"},{"path":"/reference/type.date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a Date. — type.date","text":"x object converted. ... arguments passed methods,     including format .character .Date     methods.","code":""},{"path":"/reference/type.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a default value for a column — type.default","title":"Set a default value for a column — type.default","text":"NA values replaced value. N.b. default values must provided rules validation fail.","code":""},{"path":"/reference/type.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a default value for a column — type.default","text":"","code":"type.default(value)"},{"path":"/reference/type.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a default value for a column — type.default","text":"value length one item correct type.","code":""},{"path":"/reference/type.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set a default value for a column — type.default","text":"validation function switches NAs default values","code":""},{"path":"/reference/type.double.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a double. — type.double","title":"Coerce to a double. — type.double","text":"Coerce double.","code":""},{"path":"/reference/type.double.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a double. — type.double","text":"","code":"type.double()"},{"path":"/reference/type.double.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a double. — type.double","text":"input double, error involve data loss.","code":""},{"path":"/reference/type.enum.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to match a factor with specific levels. — type.enum","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"Define conformance rule match factor specific levels.","code":""},{"path":"/reference/type.enum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"","code":"type.enum(..., .drop = FALSE, .ordered = FALSE)"},{"path":"/reference/type.enum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"... levels (quotes, backticks required) .drop levels present data specified cause error (FALSE default) silently dropped NA values (TRUE). .ordered must factor ordered","code":""},{"path":"/reference/type.enum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"function can check convert input factor specified levels. re-level factors matching levels different order.","code":""},{"path":"/reference/type.enum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to match a factor with specific levels. — type.enum","text":"","code":"f = type.enum(one,two,three) f(c(\"three\",\"two\",\"one\")) #> [1] three two   one   #> Levels: one two three f(factor(rep(1:3,5), labels = c(\"one\",\"two\",\"three\"))) #>  [1] one   two   three one   two   three one   two   three one   two   three #> [13] one   two   three #> Levels: one two three"},{"path":"/reference/type.factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a factor. — type.factor","title":"Coerce to a factor. — type.factor","text":"Coerce factor.","code":""},{"path":"/reference/type.factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a factor. — type.factor","text":"","code":"type.factor(x)"},{"path":"/reference/type.factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a factor. — type.factor","text":"x vector","code":""},{"path":"/reference/type.factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a factor. — type.factor","text":"input factor, error involve data loss.","code":""},{"path":"/reference/type.finite.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for missing values — type.finite","title":"Check for missing values — type.finite","text":"non finite values cause failure validation.","code":""},{"path":"/reference/type.finite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for missing values — type.finite","text":"","code":"type.finite(x)"},{"path":"/reference/type.finite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for missing values — type.finite","text":"x vector can coerced numeric","code":""},{"path":"/reference/type.finite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for missing values — type.finite","text":"numeric value x finite values detected","code":""},{"path":"/reference/type.group_unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a unique value. — type.group_unique","title":"Coerce to a unique value. — type.group_unique","text":"Coerce unique value.","code":""},{"path":"/reference/type.group_unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a unique value. — type.group_unique","text":"","code":"type.group_unique(x)"},{"path":"/reference/type.group_unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a unique value. — type.group_unique","text":"x vector","code":""},{"path":"/reference/type.group_unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a unique value. — type.group_unique","text":"input, error x unique.","code":""},{"path":"/reference/type.in_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"anticipated part iface rule e.g.","code":""},{"path":"/reference/type.in_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"","code":"type.in_range(min, max)"},{"path":"/reference/type.in_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"min lower limit (inclusive) max upper limit (inclusive)","code":""},{"path":"/reference/type.in_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"function checks values returns OK throws error ","code":""},{"path":"/reference/type.in_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"iface(test_col = integer + in_range(-10,10) ~ \"integer -10 10\")","code":""},{"path":"/reference/type.in_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a conformance rule to confirm that a numeric is in a set range — type.in_range","text":"","code":"type.in_range(0,100)(1:99) #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #> [51] 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #> [76] 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 try(type.in_range(0,10)(1:99)) #> Error in type.in_range(0, 10)(1:99) : values not in range: 0-10"},{"path":"/reference/type.integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to integer — type.integer","title":"Coerce to integer — type.integer","text":"Coerce integer","code":""},{"path":"/reference/type.integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to integer — type.integer","text":"","code":"type.integer(x)"},{"path":"/reference/type.integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to integer — type.integer","text":"x vector","code":""},{"path":"/reference/type.integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to integer — type.integer","text":"input integer, error involve data loss.","code":""},{"path":"/reference/type.logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a logical — type.logical","title":"Coerce to a logical — type.logical","text":"Coerce logical","code":""},{"path":"/reference/type.logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a logical — type.logical","text":"","code":"type.logical(x)"},{"path":"/reference/type.logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a logical — type.logical","text":"x vector","code":""},{"path":"/reference/type.logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a logical — type.logical","text":"input logical, error involve data loss.","code":""},{"path":"/reference/type.not_missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for missing values — type.not_missing","title":"Check for missing values — type.not_missing","text":"NA values cause failure validation.","code":""},{"path":"/reference/type.not_missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for missing values — type.not_missing","text":"","code":"type.not_missing(x)"},{"path":"/reference/type.not_missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for missing values — type.not_missing","text":"x vector, factor numeric","code":""},{"path":"/reference/type.not_missing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for missing values — type.not_missing","text":"x missing values detected","code":""},{"path":"/reference/type.numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a numeric. — type.numeric","title":"Coerce to a numeric. — type.numeric","text":"Coerce numeric.","code":""},{"path":"/reference/type.numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a numeric. — type.numeric","text":"","code":"type.numeric()"},{"path":"/reference/type.numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a numeric. — type.numeric","text":"input numeric, error involve data loss.","code":""},{"path":"/reference/type.positive_double.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a positive double. — type.positive_double","title":"Coerce to a positive double. — type.positive_double","text":"Coerce positive double.","code":""},{"path":"/reference/type.positive_double.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a positive double. — type.positive_double","text":"","code":"type.positive_double(x)"},{"path":"/reference/type.positive_double.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a positive double. — type.positive_double","text":"x object coerced tested.","code":""},{"path":"/reference/type.positive_double.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a positive double. — type.positive_double","text":"input positive double, error involve data loss.","code":""},{"path":"/reference/type.positive_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a positive integer. — type.positive_integer","title":"Coerce to a positive integer. — type.positive_integer","text":"Coerce positive integer.","code":""},{"path":"/reference/type.positive_integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a positive integer. — type.positive_integer","text":"","code":"type.positive_integer(x)"},{"path":"/reference/type.positive_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a positive integer. — type.positive_integer","text":"x vector","code":""},{"path":"/reference/type.positive_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a positive integer. — type.positive_integer","text":"input positive integer, error involve data loss.","code":""},{"path":"/reference/type.proportion.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a number between 0 and 1 — type.proportion","title":"Coerce to a number between 0 and 1 — type.proportion","text":"Coerce number 0 1","code":""},{"path":"/reference/type.proportion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a number between 0 and 1 — type.proportion","text":"","code":"type.proportion(x)"},{"path":"/reference/type.proportion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a number between 0 and 1 — type.proportion","text":"x object coerced tested.","code":""},{"path":"/reference/type.proportion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a number between 0 and 1 — type.proportion","text":"input number 0 1, error involve data loss.","code":""},{"path":"/reference/use_dataframe.html","id":null,"dir":"Reference","previous_headings":"","what":"Use a dataframe in a package including structure based documentation — use_dataframe","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"Using interfacer framework can document data development. provides basic documentation framework dataset based dataframe correct format right place.","code":""},{"path":"/reference/use_dataframe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"","code":"use_dataframe(   df,   name = deparse(substitute(df)),   output = \"R/data.R\",   pkg = \".\" )"},{"path":"/reference/use_dataframe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"df data frame use name name variable wish use (defaults whatever function called ) output write data documentation code (defaults R/data.R) pkg package (defaults current)","code":""},{"path":"/reference/use_dataframe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"nothing","code":""},{"path":"/reference/use_dataframe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use a dataframe in a package including structure based documentation — use_dataframe","text":"use case interfacer need import interfacer package, none generated code depend .","code":""},{"path":"/reference/use_iface.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate interfacer code for a dataframe — use_iface","title":"Generate interfacer code for a dataframe — use_iface","text":"Generating documenting iface given dataframe time consuming annoying automatically. case interactively develop package given dataframe's structure can explicitly documented made specific contract within package.","code":""},{"path":"/reference/use_iface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate interfacer code for a dataframe — use_iface","text":"","code":"use_iface(   df,   name = deparse(substitute(df)),   output = \"R/interfaces.R\",   use_as_default = FALSE,   pkg = \".\" )"},{"path":"/reference/use_iface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate interfacer code for a dataframe — use_iface","text":"df data frame use name name variable wish use (defaults whatever function called ) output write data documentation code (defaults R/data.R) use_as_default set true current dataframe saved package data interfacer::iface specification created referring package copy current dataframe default value. pkg package (defaults current)","code":""},{"path":"/reference/use_iface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate interfacer code for a dataframe — use_iface","text":"nothing","code":""}]
