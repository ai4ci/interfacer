% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/idispatch.R
\name{idispatch}
\alias{idispatch}
\title{Dispatch to a named function based on the characteristics of a dataframe}
\usage{
idispatch(x, ..., .default = NULL)
}
\arguments{
\item{x}{a dataframe}

\item{...}{a set of \verb{function name}=\code{interfacer::iface} pairs}

\item{.default}{a function to apply in the situation where none of the rules
can be matched. The default results in an error being thrown.}
}
\value{
the result of dispatching the dataframe to the first function that
matches the rules in \code{...}. Matching is permissive in that the test is
passed if a dataframe can be coerced to the \code{iface} specified format.
}
\description{
If multiple possible dataframe formats are possible for a function, each with
different processing requirements the decision can be made based on a validation
of the input against a set of rules. The first matching rule is used to
process the function.
}
\examples{
i1 = iface( col1 = integer ~ "An integer column" )
i2 = iface( col2 = integer ~ "A different integer column" )

# this is the structure for the function that woudl be exported
extract_mean = function(df, ...) {
  idispatch(df,
    extract_mean.i1 = i1,
    extract_mean.i2 = i2
  )
}

# this is expected to be an internal package function
# the naming convention here is based on S3 but it is not required
extract_mean.i1 = function(df = i1, ...) {
  message("using i1")
  # validation is not strictly required in this as it will already have been 
  # done unless this is an exported function
  df = ivalidate(df)
  mean(df$col1)
}

extract_mean.i2 = function(df = i2, uplift = 1, ...) {
  message("using i2")
  df = ivalidate(df)
  mean(df$col2)+uplift
}

test = tibble::tibble( col2 = 1:10 )
extract_mean(test, uplift = 50)

test2 = tibble::tibble( col1 = 1:10 )
extract_mean(test2, uplift = 50)

test3 = tibble::tibble( wrong_col = 1:10 )
try(extract_mean(test3, uplift = 50))
}
\concept{interface}
