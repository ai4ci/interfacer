---
title: "interfacer"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{interfacer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
library(interfacer)
```

# Defining an interface

An interface defines the structure of acceptable dataframes. It is a list
of column names, plus types and some documentation about the column.

```{r}
.iface = iface(
  id = integer ~ "an integer ID",
  test = logical ~ "the test result"
)
```

Printing an interface specification shows the structure.

```{r}
print(.iface)
```

An interface specification can be used as the default value for a function. This
is a dummy default value but when combined with `ivalidate` in the function body
a passed parameter can be validated to ensure the dataframe is of the right
shape. We can use `idocument` in the Roxygen skeleton to document the dataframe
constraints.

```{r}
#' An example function
#'
#' @param mydata `r idocument(example_fn, mydata)`
#' @param another an example   
#' @param ... not used
#'
#' @return the conformant dataframe
#' @export
example_fn = function(
  mydata = .iface,
  another = "value",
  ...
) {
  mydata = ivalidate(...)
  return(mydata)
}
```

In this case when we later call the function the data is checked

```{r}
example_data = tibble::tibble(
    id=c(1,2,3),
    test = c(TRUE,FALSE,TRUE)
  )

# this returns the qualifying data
example_fn(
  example_data, 
  "value for another"
)
```

If we pass non-conformant data `ivalidate` throws an error:

```{r}
example_data_2 = tibble::tibble(
    id=c(1,2,3),
    wrong_test = c(TRUE,FALSE,TRUE)
  )

# this causes an error as example_data_2$wrong_test is wrongly named
try(example_fn(
  example_data_2, 
  "value for another"
))
```

We can recover from this error by including a mapping which is applied before the
validation using an `imap` (this is essentially used for a `dplyr::mutate` call)

```{r}
example_fn(
  example_data_2, 
  "value for another",
  .imap = imap(test = wrong_test)
)

```

interface specifications can be extended. :

```{r}
.iface2 = iface(
  .iface,
  extra = character ~ "a new value",
  .groups = FALSE
)

print(.iface2)
```

and then used in another function. 

```{r}

example_fn2 = function(
    mydata = .iface2,
    ...
) {
  mydata = ivalidate(mydata, ..., .prune = TRUE)
  return(mydata)
}
```

In this case the `ivalidate` call prunes 
unneeded data from the dataframe, and also ensures that there is the correct grouping.

```{r}
example_data_3 = tibble::tibble(
    id=c(1,2,3),
    test = c(TRUE,FALSE,TRUE),
    extra = c("a","b","c"),
    unneeded = c("x","y","z")
  ) %>% dplyr::group_by(id)
```

This is rejected because the grouping is incorrect

```{r}
try(example_fn2(example_data_3))
```

Following the error message makes this validate fine

```{r}
example_fn2(example_data_3 %>% dplyr::ungroup())
```
The documentation for this second interface is as follows:

```{r}
cat(idocument(example_fn2))
```

Missing columns can be inserted with `imap`. Types are coerced to the expected
type if this is possible with no warnings.

```{r}
example_fn2(
  tibble::tibble(
    id=c("1","2","3"),
    test = c(TRUE,FALSE,TRUE)
  ), .imap = imap(extra="fixed") )
```

Incorrect data types are picked up and rejected. In this case the data supplied
for `id` cannot be cast to integer without loss. Similar behaviour is seen if
logical data is anything other than 0 or 1 for example.

```{r}
try(example_fn(
  tibble::tibble(
    id= c("1.1","2","3"),
    test = c(TRUE,FALSE,TRUE)
  )))
```

Factors might have allowable levels as well. For this we define them as an
`enum` which accepts a list of values, which then relevel the factor. If
`.drop = TRUE` is specified then values which don't match the levels will be
cast to `NA` rather than causing failure to allow conformance to a subset of factor
values.

```{r}

if (rlang::is_installed("ggplot2")) {
  
  i_diamonds = iface( 
    color = enum(D,E,F,G,H,I,J,extra) ~ "the colour",
    cut = enum(Ideal, Premium, .drop=TRUE) ~ "the cut",
    price = integer ~ "the price"
  )
  
  # itest(ggplot2::diamonds, i_diamonds)
  iconvert(ggplot2::diamonds, i_diamonds, .prune = TRUE)
  
}
```

